/*** Parse an XSPF feed and translate it to a feedarray.**/package com.jeroenwijering.parsers {import com.jeroenwijering.utils.Strings;import com.jeroenwijering.parsers.ObjectParser;public class XSPFParser extends ObjectParser {	/** Parse an XSPF playlist for feeditems. **/	public static function parse(dat:XML):Array {		var arr:Array = new Array();		var itm:Object = new Object();		for each (var i:XML in dat.children()) {			if (i.localName().toLowerCase() == 'tracklist') {				for each (var j:XML in i.children()) {					itm = XSPFParser.parseItem(j);					if(itm['type'] != undefined) {						arr.push(itm);					}					itm = {};				}			}		}		return arr;	};		private static function hasMediaExtension(s:String):Boolean {		var exts:Array = ['.flv','.jpg','.gif','.png','.mp4','.mp3'];		var s2:String = s.toLowerCase();		var gotOne:Boolean = false;				for (var i:uint=0; i < exts.length; i++) {			if (s2.indexOf(exts[i]) >= 0) gotOne = true;		}		return gotOne;	}	/** Translate XSPF item to playlist item. **/	public static function parseItem(obj:XML):Object {		var itm:Object =  new Object();		for each (var i:XML in obj.children()) {			if(!i.localName()) { break; }			switch(i.localName().toLowerCase()) {				case 'location':				    var loc:String = i.text().toString();					if (!hasMediaExtension(loc)) {						loc = decrypt(loc,'sdf883jsdf22');					}					itm['file'] = loc;					break;				case 'tracktitle':				case 'title':					itm['title'] = i.text().toString();					break;				case 'annotation':					itm['description'] = i.text().toString();					trace("item: "+itm['description']);					break;				case 'info':					itm['link'] = i.text().toString();					break;				case 'image':					itm['image'] = i.text().toString();					//itm['image'] = 'http://scottpenberthy.com/mesh/proxy.php?u='+escape(i.text().toString());					break;				case 'artist':				case 'creator':					itm['author'] = i.text().toString();					break;				case 'duration':					itm['duration'] = Strings.seconds(i.text());					break;				case 'meta':					itm[i.@rel] = i.text().toString();					break;			}		}		return ObjectParser.complete(itm);	};		private static function hexToChars(hex:String):Array {		var a:Array = new Array();		var b:int = (hex.substr(0,2) == '0x') ? 2 : 0;		while (b < hex.length) {			a.push(parseInt(hex.substr(b, 2), 16));            b += 2;		}        return a;	}		private static function charsToStr(chars:Array):String {    	var a:String = '';        var b:int = 0;        while (b < chars.length) {          a += String.fromCharCode(chars[b]);          b++;        }        return a;	}		private static function strToChars(str:String):Array {          var a:Array = new Array();          var b:int = 0;          while (b < str.length) {            a.push(str.charCodeAt(b));            ++b;          }          return a;	}		private static var _mykey:Array = new Array(256);	private static var _sbox:Array = new Array(256);		private static function initDecoder(pwd:Array):void {          var a:int = 0;          var b:int;          var c:int = pwd.length;          var d:int = 0;          while (d <= 255) {            _mykey[d] = pwd[d % c];            _sbox[d] = d;            d++;          }          d = 0;          while (d <= 255) {            a = (a + _sbox[d] + _mykey[d]) % 256;            b = _sbox[d];            _sbox[d] = _sbox[a];            _sbox[a] = b;            d++;          }	}		private static function calculate(plaintxt:Array, psw:Array):Array {          initDecoder(psw);          var a:int = 0;          var b:int = 0;          var c = new Array();          var d:int;          var e:int;          var f:int;          var g:int = 0;          while (g < plaintxt.length) {            a = (a + 1) % 256;            b = (b + _sbox[a]) % 256;            e = _sbox[a];            _sbox[a] = _sbox[b];            _sbox[b] = e;            var h:int = (_sbox[a] + _sbox[b]) % 256;            d = _sbox[h];            f = plaintxt[g] ^ d;            c.push(f);            g++;          }          return c;	}		private static function decrypt(src, key):String {          var plaintxt:Array = hexToChars(src);          var psw:Array = strToChars(key);          var chars:Array = calculate(plaintxt, psw);		  var ans:String = charsToStr(chars);          return 'http://scottpenberthy.com/mesh/proxy.php?u='+escape(ans);	}}}