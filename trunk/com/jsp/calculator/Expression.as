/*       *      Copyright 2009 (c) Scott Penberthy, scottpenberthy.com. All Rights Reserved. *       *      This software is distributed under commercial and open source licenses. *      You may use the GPL open source license described below or you may acquire  *      a commercial license from scottpenberthy.com. You agree to be fully bound  *      by the terms of either license. Consult the LICENSE.TXT distributed with  *      this software for full details. *       *      This software is open source; you can redistribute it and/or modify it  *      under the terms of the GNU General Public License as published by the  *      Free Software Foundation; either version 2 of the License, or (at your  *      option) any later version. See the GNU General Public License for more  *      details at: http://scottpenberthy.com/legal/gplLicense.html *       *      This program is distributed WITHOUT ANY WARRANTY; without even the  *      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *       *      This GPL license does NOT permit incorporating this software into  *      proprietary programs. If you are unable to comply with the GPL, you must *      acquire a commercial license to use this software. Commercial licenses  *      for this software and support services are available by contacting *      scott.penberthy@gmail.com. * */package com.jsp.calculator {		import flash.utils.Dictionary;		public class Expression {				private var _jit:Array;						// byte codes from our "just in time" compiler		private var _e:String = '';					// the current expression we're parsing        private var _sc:Scanner;					// a scanner that turns a string into tokens		private var _error:Boolean = false;			// a flag, set to true when parsing fails		private var _lastVal:String;				// the last value we saw in our expression parsing		private var _vals:Array;					// a stack of values for parsing		private var _ops:Array;						// a stack of operations for figuring out precedence		private var _trace:Boolean = false;  		// WARNING - lots of output, will hang flash		private var _eqns:Dictionary;				// we collect equations for our "blocks" here		private var _blockIds:Array;				// an array of block identifiers we see in the expression		private var _blocks:Array;					// the blocks we've parsed		private var _blockSource:Array;				// source code for our various blocks		public function Expression(expression:String='') {			_e = expression;			cleanSlate();			}				public function get raw():String {			return _e;		}				public function blockSource(id:Number):String {			if (_blocks == null) return '';			var s:String = _blockSource[id];			return s ? s : '';		}		 		public function compile():void {			firstPass();			secondPass();		}				private function firstPass():void {			block();		}				private function secondPass():void {			var len:Number = _blockIds.length;			if (len == 0) return;			_blocks = new Array(len);			for (var i:uint=0; i < len; i++) {			  var b:int = _blockIds[i];			  var e:Expression = parseBlock(b);			  _blocks[i] = e.bytecodes;			  _blockSource[i] = e.raw;			}		}				public function get bytecodes():Array {			return _jit;		}				public function get blockCount():Number {			return _blocks ? _blocks.length : 0;		}				public function getBlock(n:Number):Array {			var i:Number;			if (_blockIds) {				i = _blockIds.indexOf(n);				if (i > -1) return _blocks[i];			}			return null;		}						private function parseBlock(id:Number):Expression {			var s:String='', e:Expression;			for (var j:int=0; j < _eqns[id].length; j++) {				if (_eqns[id][j] != undefined) s += _eqns[id][j] + "\n";			}			e= new Expression(s);			e.block();			if (_trace) trace(s);			return e;		}				private function cleanSlate():void {			_eqns = new Dictionary();			_sc = new Scanner(_e.toLowerCase());			_sc.getSym();			_vals = new Array();			_ops = new Array();			_jit = new Array();			_blockIds = new Array();			_blocks = null;				_blockSource = new Array();		}				//		// Parser & compiler		//		public function block():void {			while (!_error && !accept(_sc.TOK_END)) {			  statement();			}		}				public function statement():void {			var id:String;			if (comment()) return;			if (brackets()) return;			if (blankLine()) return;			if (assignment()) return;			if (empty()) return;			_error = true;			trace("Invalid statement!");			trace(_sc.debugString());		}				public function brackets():Boolean {			if (!accept(_sc.TOK_LBRACKET)) return false;			// skip windows-style namespace indicators like [parameter00]			term();			expect(_sc.TOK_RBRACKET);			return true;		}		public function comment():Boolean {		   if (!accept(_sc.TOK_DOUBLESLASH)) return false;			// ignore comments like this one...			line();			_vals.pop(); // get rid of it, too			return true;		}		public function blankLine():Boolean {			return accept(_sc.TOK_NEWLINE);		}				public function assignment():Boolean {			var id:String, n:Number;			if (!expect(_sc.TOK_IDENTIFIER)) return false;			id = _lastVal;			if (accept(_sc.TOK_EQUAL)) {				pushString(id);				if ((n = Token.isBlock(id)) > -1) {					pushVal(n);					pushOp(_sc.TOK_EQN);					line();				}				else {				  pushOp(_sc.TOK_SET);				  expr();				}				if (accept(_sc.TOK_EQUAL)) {					pushOp(_sc.TOK_SET);					expr();				}				reduce();				accept(_sc.TOK_SEMI);			}			else {				pushVal(lookup(id));				//lookup(id);			}			return true;		}				public function expr():void {			// Left hand side		    term();			while (accept(_sc.TOK_NEWLINE));						// Optional right hand side			if (!comment()) binaryExpression();			if (_error) {				pushVal(0);				trace("Bad expression.");				trace(_sc.debugString());			}			if (_trace) {			  if (_sc.token == _sc.TOK_RPAREN) {trace("Terminated expr " + _vals[_vals.length - 1] + " with ')'");}			  if (_sc.token == _sc.TOK_COMMA) {trace("Terminated expr " + _vals[_vals.length - 1] + " with ','");}			}		}					public function empty():Boolean {			return accept(_sc.TOK_SEMI);		}				public function lookup(symbol:String):Number {			if (_trace) trace("Lookup '" + symbol + "'");			var tok:Number = Token.ize(symbol);			_jit.push(new Op(Op.LOOKUP,tok));			return 0;		}		public function store(symbol:String, val:Number):void {			var tok:uint = Token.ize(symbol);			_jit.push(new Op(Op.STORE,tok));		}				public function accept(tok:int):Boolean {			if (_sc.token == tok) {				_lastVal = _sc.symValue();				_sc.getSym();				return true;			}			else {				return false;			}		}				public function expect(tok:int):Boolean {			if (accept(tok)) return true;			// signal error!!			_error = true;			return false;		}		private function pushVal(v:Number):void {			_vals.push(v);		}				private function pushString(s:String):void {			_vals.push(s);		}				private function pushOp(o:int):void {			var thisOp:int;			var r:Boolean = false;			if (_ops.length > 0) {			  thisOp = _ops[_ops.length - 1];			  if (_trace) trace("Pushing op "+prettyTok(o)+" onto "+prettyTok(thisOp));			switch (o) {				// precedence cases go here, turning R true when				// we need to reduce				case _sc.TOK_AMP:   r = true; break;				case _sc.TOK_COMMA: r = ((thisOp != _sc.TOK_FN) &&										 (thisOp != _sc.TOK_EQUAL));  break;								case _sc.TOK_PLUS:				case _sc.TOK_MINUS: r = ((thisOp == _sc.TOK_TIMES) ||										 (thisOp == _sc.TOK_DIVIDE)); break;			}			}			if (r) {				if (_trace) trace("Reducing from pushOp");				reduce();			}			_ops.push(o);  		}				private function getVal():Number {			return Number(_vals.pop());		}				private function getString():String {			return String(_vals.pop());		}				private function line():void {			// return all characters from current pos to end of line			// as a single token			var cur:String = _sc.symValue();			_sc.getLine();			_lastVal = _sc.symValue();			_sc.getSym();			pushString(cur + _lastVal);		}		private function isString():Boolean {			if (_vals.length < 1) return false;			return(_vals[_vals.length - 1] is String);		}				private function isNumber():Boolean {			if (_vals.length < 1) return false;			return (_vals[_vals.length - 1] is Number);		}				private function getOp():int {			return _ops.pop();		}						private function equals():void {			var val:Number = getVal();			var id:String= getString();			store(id, val);			pushVal(val);		}				private function storeEquation(id:Number, parm:String, line:Number, eqn:String):void {			if (parm != '') {				_eqns[id].push(parm+"="+eqn);			}			else {				_eqns[id][line] = eqn;			}		}		private function equation():void {			var eqn:String = getString();			var blockId:Number = getVal();			var fn:String = getString();			var lineNum:Number = Token.blockNum(fn,blockId);			var parm:String = Token.blockParm(fn,blockId);			if (_eqns[blockId]) {				storeEquation(blockId, parm, lineNum, eqn);			}			else {				_blockIds.push(blockId);				_eqns[blockId] = new Array();				storeEquation(blockId, parm, lineNum, eqn);			}			if (_trace) trace("Equation " + fn + ", blockId="+blockId+", n="+lineNum+", "+ eqn);		}		private function reduce():void {			var t:int = getOp();			if (_trace) trace("Reduce called for "+prettyTok(t));			switch (t) {				case _sc.TOK_TIMES:  			binaryFun('*'); break;				case _sc.TOK_PLUS:   			binaryFun('+'); break;				case _sc.TOK_DIVIDE:			binaryFun('/'); break; 						case _sc.TOK_MOD:    			binaryFun('%'); break;				case _sc.TOK_MINUS:  			binaryFun('-'); break;				case _sc.TOK_AMP:    			binaryFun('&'); break;				case _sc.TOK_OR:     			binaryFun('|'); break;				case _sc.TOK_FN:    			pushOp(t); break;				case _sc.TOK_EQN: 				equation(); break;				case _sc.TOK_SET:    			equals(); break;			}		}				public function prettyTok(t:int):String {			switch (t) {				case _sc.TOK_TIMES: return '*'; break;				case _sc.TOK_PLUS:   return '+'; break;				case _sc.TOK_DIVIDE: return '/'; break;				case _sc.TOK_MOD:    return '%'; break;				case _sc.TOK_MINUS:  return '-'; break;				case _sc.TOK_AMP:    return '&'; break;				case _sc.TOK_OR:     return '|'; break;				case _sc.TOK_FN:     return 'CustomFunction';  break;				case _sc.TOK_EQN: 	 return 'Equation'; break;				case _sc.TOK_SET:    return '=';  break;				default: return '???';			}		}						public function parseFunction(f:String):void {			// parse a function call and leave the value on the var stack			var v1:Number, v2:Number, v3:Number;			var ftok:Number = Token.ize(f);			var args:Number = Token.arity[ftok];			switch (args) {				case 1:		unary(f); break;				case 2:		binary(f); break;				case 3:		tertiary(f); break;				default:	_error = true; trace("Bad function - "+f); trace(_sc.debugString()); break;			}		}				public function unary(f:String):void {			var v1:Number, v2:Number;			pushOp(_sc.TOK_FN);			expr();			expect(_sc.TOK_RPAREN);			v1 = getVal();			v2 = applyFn(f,v1);			if (_trace) trace("Unary function "+f+"("+v1+")");			if (_trace && _error) trace("  ** WITH ERROR");			pushVal(v2);			getOp();		}				public function binary(f:String):void {			var v1:Number, v2:Number, v3:Number;			pushOp(_sc.TOK_FN);			expr();			expect(_sc.TOK_COMMA);			expr();			expect(_sc.TOK_RPAREN);			binaryFun(f);			getOp();		}				private function binaryFun(op:String):void {			var v2:Number = getVal();			var v1:Number = getVal();			var v3:Number = applyFn(op,v1,v2);			pushVal(v3);		}				public function tertiary(f:String):void {			var v1:Number, v2:Number, v3:Number;			var v4:Number;			pushOp(_sc.TOK_FN);			expr();			expect(_sc.TOK_COMMA);			expr();			expect(_sc.TOK_COMMA);			expr();			expect(_sc.TOK_RPAREN);			v3 = getVal();			v2 = getVal();			v1 = getVal();			v4 = applyFn(f,v1,v2,v3);			pushVal(v4);			getOp();		}				public function identifier():Boolean {			var val:String;			if (accept(_sc.TOK_IDENTIFIER)) {				val = _lastVal;				if (accept(_sc.TOK_LPAREN)) {					if (_trace) trace("Parsing function "+val);					parseFunction(val);				}				else pushVal(lookup(val));				return true;			}				return false;		}				public function number():Boolean {			if (accept(_sc.TOK_NUMBER)) {            	_jit.push(new Op(Op.PUSH, 0, Number(_lastVal)));				pushVal(Number(_lastVal));				return true;			}			return false;		}				public function unaryMinus():Boolean {			// unary minus X = -1 * x			if (!accept(_sc.TOK_MINUS)) return false;			if (accept(_sc.TOK_NEWLINE)) {				// odd case of foo=-  with a hard return.  We'll treat it as zero.				_jit.push(new Op(Op.PUSH,0,0));				return true;			}			var v1:Number;			expr();			v1 = getVal();			pushVal(-1 * v1);			_jit.push(new Op(Op.PUSH,0,-1));			_jit.push(new Op(Op.CALL2,Token.ize('*')));			return true;		}				public function unaryPlus():Boolean {			if (accept(_sc.TOK_PLUS)) {				expr();				return true;			}			return false;		}				public function parenthetical():Boolean {			if (!accept(_sc.TOK_LPAREN)) return false;			if (_trace) trace("Found term surrounded by parentheses ()");			pushOp(_sc.TOK_FN); // don't reduce across the paren boundaries!			expr();			if (!expect(_sc.TOK_RPAREN)) {				trace("ERROR in parentheses syntax.  Abandon.");				trace(_sc.debugString());				pushVal(0);			}			getOp();			return true;		}		public function term():void {			var val:String;			var val2:String;			while (accept(_sc.TOK_NEWLINE));			if (comment()) return term(); //foo			if (identifier()) return;			if (number()) return;			if (unaryMinus()) return;			if (unaryPlus()) return;			if (parenthetical()) return;						_error = true;			trace("Bad term");			trace(_sc.debugString());		}		public function binaryExpression():Boolean {			var tokens:Array = [_sc.TOK_TIMES,_sc.TOK_PLUS,_sc.TOK_MINUS,_sc.TOK_DIVIDE,			 					_sc.TOK_MOD, _sc.TOK_AMP, _sc.TOK_OR];			var t:uint;			for (var i:int=tokens.length-1; i >= 0; i--){				t = tokens[i];				if (accept(t)) {					pushOp(t);					expr();					if (_trace) trace("Reducing from binaryExp "+prettyTok(t));					reduce();					return true;				}			}			return false;		}					public function applyFn(f:String, ... args):Number {			var tok:Number = Token.ize(f);			var arity:Number = Token.arity[tok];			var opcode:uint = 0;			var op:Op;			switch (arity) {				case 1:		opcode = Op.CALL1; break; 				case 2:		opcode = Op.CALL2; break;				case 3:		opcode = Op.CALL3; break;			}			op = new Op(opcode,tok);			_jit.push(op);			return 0;		}				public function showOps(ops:Array):void {			for (var i:int=0; i < ops.length; i++) {				var o:Op = ops[i];				trace(o.toString());			}		}				public function showBlocks():void {			if (_blocks != null) {				for (var i:int=0; i < _blocks.length; i++) {					trace("** Block "+Token.t2b[_blockIds[i]]);					//showOps(_blocks[i]);				}			}		}				public function blockCodes(blockId:Number):Array {			if (_blocks == null) return null;						for (var i:int=0; i < _blocks.length; i++) {				if (_blockIds[i] == blockId) return _blocks[i];			}			return null;		}				public function showJit():void {			var o:Op;			if (_jit.length > 0) {				trace("***Our just-in-time compiler produced:\nBEGIN");				showOps(_jit);				trace("END\n***");			}			showBlocks();		}				public function monitor(blockId:Number):String {			// Analyze the instruction set and determine the variable			// we want to "monitor."			var lastLookup:uint = 0;			var monitor:uint = Token.ize('monitor');			var ops:Array = blockCodes(blockId);			if (ops && ops.length > 0) {				for (var i:int=0; i < ops.length; i++) {					var o:Op = ops[i];					if (o.code == Op.LOOKUP) lastLookup = o.token;					if (o.code == Op.STORE && o.token == monitor) {						return Token.t2s[lastLookup];					}				}			}			return null;		}	}}