/*       *      Copyright 2009 (c) Scott Penberthy, scottpenberthy.com. All Rights Reserved. *       *      This software is distributed under commercial and open source licenses. *      You may use the GPL open source license described below or you may acquire  *      a commercial license from scottpenberthy.com. You agree to be fully bound  *      by the terms of either license. Consult the LICENSE.TXT distributed with  *      this software for full details. *       *      This software is open source; you can redistribute it and/or modify it  *      under the terms of the GNU General Public License as published by the  *      Free Software Foundation; either version 2 of the License, or (at your  *      option) any later version. See the GNU General Public License for more  *      details at: http://scottpenberthy.com/legal/gplLicense.html *       *      This program is distributed WITHOUT ANY WARRANTY; without even the  *      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *       *      This GPL license does NOT permit incorporating this software into  *      proprietary programs. If you are unable to comply with the GPL, you must *      acquire a commercial license to use this software. Commercial licenses  *      for this software and support services are available by contacting *      scott.penberthy@gmail.com. * */package com.jsp.calculator{		// FIX ME... where should I go?			public class Milk extends SymbolTable	{				public static const	NUM_SHAPES			:Number = 4;		public static var   READ_ONLY_START		:Number;		public static var   READ_ONLY_END		:Number;				public static var	PIXEL_START			:Number;		public static var   PIXEL_END			:Number;				public static var 	WAVE_DOTS			:Number;		public static var	MAX_COLOR 			:Number;		public static var	DARKCENTER 			:Number;		public static var	WAVE_ALPHA_START 	:Number;		public static var	WAVE_ALPHA_END 		:Number;		public static var	WARP_SPEED			:Number;		public static var	WARP_SCALE 			:Number;		public static var	ZOOM 				:Number;		public static var	ZOOM_EXP 			:Number;		public static var	ROT 				:Number;		public static var	CX 					:Number;		public static var	CY 					:Number;		public static var	DX 					:Number;		public static var	DY 					:Number;		public static var	SX 					:Number;		public static var	SY 					:Number;		public static var	WAVE_MODE 			:Number;		public static var	WAVE_X 				:Number;		public static var	WAVE_Y 				:Number;		public static var	WAVE_R 				:Number;		public static var	WAVE_G 				:Number;		public static var	WAVE_B 				:Number;		public static var	WAVE_A 				:Number;		public static var	WAVE_PARAM 			:Number;		public static var   WAVE_MYSTERY        :Number;		public static var	WAVE_THICK 			:Number;		public static var	WAVE_ADDITIVE 		:Number;		public static var	WAVE_BRIGHTEN 		:Number;		public static var	OB_SIZE 			:Number;		public static var	OB_R 				:Number;		public static var	OB_G 				:Number;		public static var	OB_B 				:Number;		public static var	OB_A 				:Number;		public static var	IB_SIZE 			:Number;		public static var	IB_R 				:Number;		public static var	IB_G 				:Number;		public static var	IB_B 				:Number;		public static var	IB_A 				:Number;		public static var	DECAY 				:Number;		public static var	SCALE 				:Number;		public static var	SCALE_SOUND 		:Number;		public static var	SMOOTH 				:Number;		public static var	INTERPOLATE 		:Number;		public static var	WARP 				:Number;		public static var	MOUSE_X 			:Number;		public static var	MOUSE_Y 			:Number;		public static var	X 					:Number;		public static var	Y 					:Number;		public static var	ANG 				:Number;		public static var	RAD 				:Number;		public static var	MOTIONVECTORS 		:Number;		public static var	MV_R 				:Number;		public static var	MV_G 				:Number;		public static var	MV_B 				:Number;		public static var	MV_A 				:Number;		public static var	MV_X 				:Number;		public static var	MV_Y 				:Number;		public static var	MV_DX 				:Number;		public static var	MV_DY 				:Number;		public static var	MV_L 				:Number;		public static var	Q1 					:Number;		public static var	Q2 					:Number;		public static var	Q3 					:Number;		public static var	Q4 					:Number;		public static var	Q5 					:Number;		public static var	Q6 					:Number;		public static var	Q7 					:Number;		public static var	Q8 					:Number;		public static var	Q9 					:Number;		public static var	T1 					:Number;		public static var	T2 					:Number;		public static var	T3 					:Number;		public static var	T4 					:Number;		public static var	T5 					:Number;		public static var	T6 					:Number;		public static var	T7 					:Number;		public static var	T8 					:Number;		public static var	GAMMA 				:Number;		public static var	VE_ZOOM 			:Number;		public static var	VE_ORIENT 			:Number;		public static var	VE_ALPHA 			:Number;		public static var	DARKEN_CENTER 		:Number;		public static var	WRAP 				:Number;		public static var	INVERT 				:Number;		public static var	BRIGHTEN 			:Number;		public static var	DARKEN 				:Number;		public static var	SOLARIZE 			:Number;		public static var	MONITOR 			:Number;		public static var	TIME 				:Number;		public static var	FRAME 				:Number;		public static var	MID 				:Number;		public static var	BASS 				:Number;		public static var	TREBLE 				:Number;		public static var	MID_ATT 			:Number;		public static var	BASS_ATT 			:Number;		public static var	TREBLE_ATT 			:Number;		public static var	AMP 				:Number;		public static var	ENABLED 			:Number;		public static var	SIDES 				:Number;		public static var	THICK 				:Number;		public static var	ADDITIVE 			:Number;		public static var	TEXTURED 			:Number;		public static var	TEX_ZOOM 			:Number;		public static var	TEX_ANG 			:Number;		public static var	R 					:Number;		public static var	G 					:Number;		public static var	B 					:Number;		public static var	A 					:Number;		public static var	R2 					:Number;		public static var	G2 					:Number;		public static var	B2 					:Number;		public static var	A2 					:Number;		public static var	BORDER_R 			:Number;		public static var	BORDER_G 			:Number;		public static var	BORDER_B 			:Number;		public static var	BORDER_A 			:Number;		public static var	MESHX 				:Number;		public static var	MESHY 				:Number;		public static var	FPS 				:Number;		public static var	RATING 				:Number;		public static var	PROGRESS 			:Number;		public static var	SAMPLE 				:Number;		public static var	VALUE1 				:Number;		public static var	VALUE2 				:Number;		public static var	USEDOTS 			:Number;		public static var	SPECTRUMWAVE 		:Number;		public static var	NUMSAMPLES 			:Number;		public static var	WAVESEPARATION 		:Number;		public static var	MOD_WAVE_ALPHA_BY_VOLUME :Number;				public static var   FRAME_START			:Number;				// first index for frame vars		public static var   FRAME_END			:Number;				// last index of frame vars				public function Milk()		{			super();		}				override public function registerBlocks():void {			// we name all the different blocks of code,			// which are essentially global functions			registerFrameBlocks();			registerPixelBlocks();			registerShapeBlocks();			registerWaveBlocks();		}				//		// The following static class variables hold the token id's for the name		// of various code blocks used in Milkdrop.  Code blocks are used to program		// a frame, the pixel shader, shapes, and waves at various points of the program's		// execution.  These can occur at initialization time, at every frame, at every pixel.		//		// Programmable waves, shapes, frames and shaders refer to these code block id's,		// which are persistent and constant across all presets for speed.		//				//		// Frame equation block identifiers		//		// Milk.frame.code - holds code to run at every frame		// Milk.frame.init - holds code to run at initialization				public static var frame:Object;				private function registerFrameBlocks():void {			frame = {code: Token.registerBlock('per_frame_', true),			         init: Token.registerBlock('per_frame_init', true)			         };		}				//		// Pixel equation block identifiers		//		// Milk.pixel.code  - holds code to run at every pixel		// Milk.pixel.init  - holds code to run once, at initialization				public static var pixel:Object;				private function registerPixelBlocks():void {			pixel = {code: Token.registerBlock('per_pixel_', true),			         init: Token.registerBlock('per_pixel_init', true)			         };		}				//		// Shape equation block identifiers		//		// Milk.shape[i].code - code to configure the shape, run once		// Milk.shape[i].init - code to initialize a shape, run once		// Milk.shape[i].per_point - not supported		// Milk.shape[i].per_frame_init - code to run to initialize frame values		// Milk.shape[i].per_frame - code to run at every frame				public static var shape:Array;				private function registerShapeBlocks():void {			shape = new Array();			for (var i:uint=0; i < NUM_SHAPES; i++) {				shape[i] = {code: Token.registerBlock('shapecode_'+i+'_',true), // used to be false						    init: Token.registerBlock('shape_'+i+'_init', true),						 	per_point: Token.registerBlock('shape_'+i+'_per_point',true),							per_frame_init: Token.registerBlock('shape_'+i+'_per_frame_init',true),							per_frame: Token.registerBlock('shape_'+i+'_per_frame',true)							}			}		}				//		// Wave equation block identifiers		//		// Milk.wave[i].code - code to configure the wave, run once		// Milk.wave[i].init - code to initialize a wave, run once		// Milk.wave[i].per_point - code to be run at every point of the wave		// Milk.wave[i].per_frame_init - code to run to initialize frame values		// Milk.wave[i].per_frame - code to run at every frame				public static var wave:Array;				private function registerWaveBlocks():void {			wave = new Array();			for (var i:uint=0; i < 4; i++) {				wave[i] = {code: Token.registerBlock('wavecode_'+i+'_',false),				 			init: Token.registerBlock('wave_'+i+'_init', true),				  	 		per_point: Token.registerBlock('wave_'+i+'_per_point',true),							per_frame_init: Token.registerBlock('wave_'+i+'_per_frame_init',true),							per_frame: Token.registerBlock('wave_'+i+'_per_frame',true)							}			}		}				//		// Symbols		//				override public function registerSymbols():void {						//			// Variables that affect pixel motion			//			ZOOM 				= Token.registerSymbol("zoom");			FRAME_START = ZOOM;			PIXEL_START = ZOOM;						ZOOM_EXP			= Token.registerSymbol("zoom_exp");			ROT 				= Token.registerSymbol("rot");			WARP 				= Token.registerSymbol("warp");			WARP_SPEED 			= Token.registerSymbol("warp_speed");			WARP_SCALE 			= Token.registerSymbol("warp_scale");			CX 					= Token.registerSymbol("cx");			CY 					= Token.registerSymbol("cy");			DX 					= Token.registerSymbol("dx");			DY 					= Token.registerSymbol("dy");			SX 					= Token.registerSymbol("sx");			SY 					= Token.registerSymbol("sy");						// Read only variables			TIME 				= Token.registerSymbol("time");			FPS 				= Token.registerSymbol("fps");			MOUSE_X 			= Token.registerSymbol("mouse_x");			MOUSE_Y 			= Token.registerSymbol("mouse_y");			BASS 				= Token.registerSymbol("bass");			MID 				= Token.registerSymbol("mid");			TREBLE 				= Token.registerSymbol("treble");			BASS_ATT 			= Token.registerSymbol("bass_att");			MID_ATT 			= Token.registerSymbol("mid_att");			TREBLE_ATT 			= Token.registerSymbol("treble_att");			AMP 				= Token.registerSymbol("amp");			FRAME 				= Token.registerSymbol("frame");			MESHX 				= Token.registerSymbol("meshx");			MESHY 				= Token.registerSymbol("meshy");						// Record the range of read-only variables for			// fast copying.			READ_ONLY_START 	= TIME;			READ_ONLY_END		= MESHY;						// Shared vars, initialized in frame 0			Q1 					= Token.registerSymbol("q1");			Q2 					= Token.registerSymbol("q2");			Q3 					= Token.registerSymbol("q3");			Q4 					= Token.registerSymbol("q4");			Q5 					= Token.registerSymbol("q5");			Q6 					= Token.registerSymbol("q6");			Q7 					= Token.registerSymbol("q7");			Q8 					= Token.registerSymbol("q8");			Q9 					= Token.registerSymbol("q9");						PROGRESS 			= Token.registerSymbol("progress");			MONITOR 			= Token.registerSymbol("monitor");						PIXEL_END			= PROGRESS;						// 			// Variables that do not affect pixel motion			//						// Sustain			DECAY 				= Token.registerSymbol("decay");						// Wave			WAVE_A 				= Token.registerSymbol("wave_a");			WAVE_R 				= Token.registerSymbol("wave_r");			WAVE_G 				= Token.registerSymbol("wave_g");			WAVE_B 				= Token.registerSymbol("wave_b");			WAVE_X 				= Token.registerSymbol("wave_x");			WAVE_Y 				= Token.registerSymbol("wave_y");			WAVE_MYSTERY		= Token.registerSymbol("wave_mystery");			WAVE_MODE 			= Token.registerSymbol("wave_mode");						// Border			OB_SIZE 			= Token.registerSymbol("ob_size");			OB_R 				= Token.registerSymbol("ob_r");			OB_G 				= Token.registerSymbol("ob_g");			OB_B 				= Token.registerSymbol("ob_b");			OB_A 				= Token.registerSymbol("ob_a");			IB_SIZE 			= Token.registerSymbol("ib_size");			IB_R 				= Token.registerSymbol("ib_r");			IB_G 				= Token.registerSymbol("ib_g");			IB_B 				= Token.registerSymbol("ib_b");			IB_A 				= Token.registerSymbol("ib_a");						// Motion vectors			MV_R 				= Token.registerSymbol("mv_r");			MV_G 				= Token.registerSymbol("mv_g");			MV_B 				= Token.registerSymbol("mv_b");			MV_A 				= Token.registerSymbol("mv_a");			MV_X 				= Token.registerSymbol("mv_x");			MV_Y 				= Token.registerSymbol("mv_y");			MV_DX 				= Token.registerSymbol("mv_dx");			MV_DY 				= Token.registerSymbol("mv_dy");			MV_L 				= Token.registerSymbol("mv_l");						// Video echo			VE_ZOOM 			= Token.registerSymbol("ve_zoom");			VE_ORIENT 			= Token.registerSymbol("ve_orient");			VE_ALPHA 			= Token.registerSymbol("ve_alpha");						// Effects			WAVE_DOTS 			= Token.registerSymbol("wave_dots");			WAVE_THICK 			= Token.registerSymbol("wave_thick");			WAVE_ADDITIVE 		= Token.registerSymbol("wave_additive");			WAVE_BRIGHTEN 		= Token.registerSymbol("wave_brighten");			DARKCENTER 			= Token.registerSymbol("darkcenter");			DARKEN_CENTER 		= Token.registerSymbol("darken_center");			GAMMA 				= Token.registerSymbol("gamma");			WRAP 				= Token.registerSymbol("wrap");			INVERT 				= Token.registerSymbol("invert");			BRIGHTEN 			= Token.registerSymbol("brighten");			DARKEN 				= Token.registerSymbol("darken");			SOLARIZE 			= Token.registerSymbol("solarize");									FRAME_END = SOLARIZE;						SCALE 				= Token.registerSymbol("scale");			MOTIONVECTORS 		= Token.registerSymbol("motionVectors");			RATING 				= Token.registerSymbol("rating");						//			// Wave class			//			MAX_COLOR 			= Token.registerSymbol("max_color");			WAVE_ALPHA_START 	= Token.registerSymbol("wave_alpha_start");			WAVE_ALPHA_END 		= Token.registerSymbol("wave_alpha_end");						MOD_WAVE_ALPHA_BY_VOLUME = Token.registerSymbol("mod_wave_alpha_by_volume");									//			// Sampler class			//			SCALE_SOUND 		= Token.registerSymbol("scale_sound");			SMOOTH 				= Token.registerSymbol("smooth");			INTERPOLATE 		= Token.registerSymbol("interpolate");						//			// Custom wave class			//			USEDOTS 			= Token.registerSymbol("usedots");			SPECTRUMWAVE 		= Token.registerSymbol('spectrumWave');			NUMSAMPLES 			= Token.registerSymbol('numSamples');			WAVESEPARATION 		= Token.registerSymbol('waveSeparation');			VALUE1 				= Token.registerSymbol("value1");			VALUE2 				= Token.registerSymbol("value2");			X 					= Token.registerSymbol("x");			Y 					= Token.registerSymbol("y");			ANG 				= Token.registerSymbol("ang");			RAD 				= Token.registerSymbol("rad");			//			// Shape 			//			ENABLED 			= Token.registerSymbol("enabled");			SIDES 				= Token.registerSymbol("sides");			THICK 				= Token.registerSymbol("thick");			ADDITIVE 			= Token.registerSymbol("additive");			R 					= Token.registerSymbol("r");			G 					= Token.registerSymbol("g");			B 					= Token.registerSymbol("b");			A 					= Token.registerSymbol("a");			R2 					= Token.registerSymbol("r2");			G2 					= Token.registerSymbol("g2");			B2 					= Token.registerSymbol("b2");			A2 					= Token.registerSymbol("a2");			BORDER_R 			= Token.registerSymbol("border_r");			BORDER_G 			= Token.registerSymbol("border_g");			BORDER_B 			= Token.registerSymbol("border_b");			BORDER_A 			= Token.registerSymbol("border_a");			T1 					= Token.registerSymbol("t1");			T2 					= Token.registerSymbol("t2");			T3 					= Token.registerSymbol("t3");			T4 					= Token.registerSymbol("t4");			T5 					= Token.registerSymbol("t5");			T6 					= Token.registerSymbol("t6");			T7 					= Token.registerSymbol("t7");			T8 					= Token.registerSymbol("t8");						//			// Textured effect			//			TEXTURED 			= Token.registerSymbol("textured");			TEX_ZOOM 			= Token.registerSymbol("tex_zoom");			TEX_ANG 			= Token.registerSymbol("tex_ang");			SAMPLE 				= Token.registerSymbol("sample");						// Preset parameters			var _parms:Array = ['fvideoechoalpha','fvideoechozoom','nvideoechoorientation','bmotionvectorson',								'nwavemode','badditivewaves','bmaximizewavecolor','btexwrap',								'bdarkencenter','dark_center','nmotionvectorsx','nmotionvectorsy','bbrighten',								'bdarken','binvert','bsolarize','fwavealpha','bwavedots',								'bwavethick','fwavescale','wave_scale','wave_smooth',								'fmodwavealphastart','fmodwavealphaend','fwarpanimspeed',								'fwarpscale','fzoomexponent','shader','preset',								'fwavesmoothing','fshader','fwaveparam'];			for (var i:int=0; i < _parms.length; i++) {				Token.registerSymbol(_parms[i]);			}		}			}}