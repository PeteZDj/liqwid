 /*       *      Copyright 2009 (c) Scott Penberthy, scottpenberthy.com. All Rights Reserved. *       *      This software is distributed under commercial and open source licenses. *      You may use the GPL open source license described below or you may acquire  *      a commercial license from scottpenberthy.com. You agree to be fully bound  *      by the terms of either license. Consult the LICENSE.TXT distributed with  *      this software for full details. *       *      This software is open source; you can redistribute it and/or modify it  *      under the terms of the GNU General Public License as published by the  *      Free Software Foundation; either version 2 of the License, or (at your  *      option) any later version. See the GNU General Public License for more  *      details at: http://scottpenberthy.com/legal/gplLicense.html *       *      This program is distributed WITHOUT ANY WARRANTY; without even the  *      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *       *      This GPL license does NOT permit incorporating this software into  *      proprietary programs. If you are unable to comply with the GPL, you must *      acquire a commercial license to use this software. Commercial licenses  *      for this software and support services are available by contacting *      scott.penberthy@gmail.com. * */package com.jsp.calculator{	public class Calculator	{		private var _vm:VirtualMachine;		private var _mem:Array;		private static var _sym:SymbolTable = null;		private var _bytecodes:Array;		private var _map:Array;				public function Calculator()		{			init();		}				private function init():void {			if (!_sym) _sym = new SymbolTable();			_vm = new VirtualMachine();			_mem = new Array(Token.memorySize());			_map = new Array();			_bytecodes = null;			clearMemory();		}				public function clear():void {			clearMemory();		}				public function set bytecodes(codes:Array):void {			_bytecodes = codes;			expandMemory();		}				public function get bytecodes():Array {			return _bytecodes;		}				public function load(expression:String):void {			var e:Expression = new Expression(expression);			e.compile();			_bytecodes = e.bytecodes;			expandMemory();			e.showBlocks();  // TODO get rid of me.		}				public function eval():void {			if (_bytecodes) _vm.eval(_bytecodes, _mem);			//else trace("No bytecodes!");		}				private function fetch(name:String):int {			var cached:int = _map[name];			if (!_map.hasOwnProperty(name)) {				cached = Token.ize(name);				_map[name] = cached;			}			return cached;		}				public function lookup(variable:String):Number {			var id:int = fetch(variable);			if (id > -1) {				//if (id > _mem.length) trace("** Lookup "+variable+" "+id+" outside range "+_mem.length); //expandMemory();				return _mem[id];			}			else {				return NaN;			}		}				public function makeFunctionBlock(args:Array):Array {			//			// Take an array of argument names, args, and return			// a function block for fast calling to/from a calculator.			//			// A function block is an array of objects 			//  {id: id, value: value, name: name}			//			var fblock:Array = new Array();			var id:int;			var name:String;			var len:int = args.length;						for (var i:int=0; i < len; i++) {				name = args[i];				fblock.push({id: fetch(name), value: 0, name: name});			}			return fblock;		}				public function call(fblock:Array):void {			store_block(fblock);			eval();			fetch_block(fblock);		}				private function store_block(fblock:Array):void {			var len:int = fblock.length;			var b:Object;			for (var i:int=0; i < len; i++) {				b = fblock[i];				_mem[b.id] = b.value;			}		}				private function fetch_block(fblock:Array):void {			var len:int = fblock.length;			var b:Object;			for (var i:int=0; i < len; i++) {				b = fblock[i];				b.value = _mem[b.id];			}		}				public function store(variable:String, value:Number):void {			var id:int = fetch(variable);			if (id > -1) {				if (id > _mem.length) trace("** Store "+variable+" "+id+" outside range "+_mem.length); //expandMemory();				_mem[id] = value;			}		}				public function get memory():Array {			return _mem;		}				public function set memory(a:Array):void {			_mem = a;		}				//		// Helper functions for the calculator		//						private function clearMemory():void {			var len:int = _mem.length;			for (var i:int=0; i < len; i++) _mem[i]=0;		}				public function expandMemory():void {			var newLen:int = Token.memorySize();			var len:int = _mem.length;			for (var i:int=len; i < newLen; i++) _mem[i]=0;		}			}}