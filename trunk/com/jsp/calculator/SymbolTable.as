/*       *      Copyright 2009 (c) Scott Penberthy, scottpenberthy.com. All Rights Reserved. *       *      This software is distributed under commercial and open source licenses. *      You may use the GPL open source license described below or you may acquire  *      a commercial license from scottpenberthy.com. You agree to be fully bound  *      by the terms of either license. Consult the LICENSE.TXT distributed with  *      this software for full details. *       *      This software is open source; you can redistribute it and/or modify it  *      under the terms of the GNU General Public License as published by the  *      Free Software Foundation; either version 2 of the License, or (at your  *      option) any later version. See the GNU General Public License for more  *      details at: http://scottpenberthy.com/legal/gplLicense.html *       *      This program is distributed WITHOUT ANY WARRANTY; without even the  *      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *       *      This GPL license does NOT permit incorporating this software into  *      proprietary programs. If you are unable to comply with the GPL, you must *      acquire a commercial license to use this software. Commercial licenses  *      for this software and support services are available by contacting *      scott.penberthy@gmail.com. * */package com.jsp.calculator{	public class SymbolTable	{		public static var _init:Boolean = false;						public function SymbolTable()		{			if (!_init) init();		}				public function init():void {			registerSymbols();			registerFunctions();			registerBlocks();		}				//		// Prefixes		//				public function registerBlocks():void {		}				//		// Symbols		//				public function registerSymbols():void {		}									//		// Functions - shared by all		//			public function registerFunctions():void {			Token.registerFunction('*', 	mTimes, 		2); 			Token.registerFunction('+', 	mPlus, 			2);			Token.registerFunction('-', 	mMinus, 		2);					Token.registerFunction('/', 	mDivide, 		2);			Token.registerFunction('%', 	mModulo, 		2);  			Token.registerFunction('&', 	mAnd, 			2); 			Token.registerFunction('|', 	mOr, 			2);			Token.registerFunction('int', 	Math.floor, 	1);					Token.registerFunction('abs', 	Math.abs, 		1); 			Token.registerFunction('exp', 	Math.exp, 		1); 			Token.registerFunction('sin', 	Math.sin, 		1); 				Token.registerFunction('cos', 	Math.cos, 		1);			Token.registerFunction('tan', 	Math.tan, 		1);			Token.registerFunction('asin', 	Math.asin, 		1);			Token.registerFunction('acos', 	Math.acos, 		1);			Token.registerFunction('atan', 	Math.atan, 		1);			Token.registerFunction('atan2', Math.atan2, 	2);			Token.registerFunction('sqr', 	fn_sqr, 		1);			Token.registerFunction('sqrt',	Math.sqrt, 		1); 			Token.registerFunction('pow', 	fn_pow, 		2);			Token.registerFunction('log', 	mLog, 			1); 			Token.registerFunction('log10', fn_log10, 		1);			Token.registerFunction('sign', 	fn_sign, 		1);			Token.registerFunction('min',	Math.min,		2);			Token.registerFunction('max', 	Math.max,		2);			Token.registerFunction('sig', 	fn_sigmoid,		2);			Token.registerFunction('sigmoid',fn_sigmoid,	2);			Token.registerFunction('rand',	fn_rand,		1);			Token.registerFunction('bor',	fn_bor,			2);			Token.registerFunction('bnot', 	fn_bnot,		1);			Token.registerFunction('band',	fn_band,		2);			Token.registerFunction('if',	fn_if,			3);			Token.registerFunction('equal', fn_equal,		2);			Token.registerFunction('above', fn_above,		2);			Token.registerFunction('below',	fn_below,		2);		}			/**				 These are the functions supported by the MilkDrop equations:				    int(var)   :  returns the integer value of 'var' (rounds toward zero)            abs(var)   :  returns the absolute value of var            sin(var)   :  returns the sine of the angle var (expressed in radians)            cos(var)   :  returns the cosine of the angle var            tan(var)   :  returns the tangent of the angle var            asin(var)  :  returns the arcsine of var            acos(var)  :  returns the arccosine of var            atan(var)  :  returns the arctangent of var			atan2(var1,var2): return the arctange of var1/var2            sqr(var)   :  returns the square of var            sqrt(var)  :  returns the square root of var            pow(var,var2) : returns var to the power of var2            log(var)      : returns the log base e of var            log10(var)    : returns the log base 10 of var            sign(var)     : returns the sign of var or 0            min(var,var2) : returns the smalest value            max(var,var2) : returns the greatest value            sigmoid(var,var2) : returns sigmoid function value of x=var (var2=constraint)            rand(var)     : returns a random integer modulo 'var'; e.g. rand(4) will return 0, 1, 2, or 3.            bor(var,var2) : boolean or, returns 1 if var or var2 is != 0            bnot(var)  : boolean not, returns 1 if var == 0 or 0 if var != 0            if(cond,vartrue,varfalse) : if condition is nonzero, returns valtrue, otherwise returns valfalse            equal(var,var2) : returns 1 if var = var2, else 0            above(var,var2) : returns 1 if var > var2, else 0            below(var,var2) : returns 1 if var < var2, else 0              exp(var) : return e^var					**/						private function mTimes(v1:Number,v2:Number):Number {			return v1*v2;		}				private function mPlus(v1:Number,v2:Number):Number {			return v1+v2;		}				private function mMinus(v1:Number,v2:Number):Number {			return v1-v2;		}				private function mDivide(v1:Number,v2:Number):Number {			if (v2 == 0) return 0;			return v1/v2;		}				private function mModulo(v1:Number,v2:Number):Number {			if (v2 == 0) return 0;			return v1%v2;		}				private function mAnd(v1:Number,v2:Number):Number {			return int(v1) & int(v2);		}				private function mOr(v1:Number,v2:Number):Number {			return int(v1) | int(v2);		}				private function mLog(v1:Number):Number {			if (v1 <= 0) return 0; return Math.log(v1);		}		public function fn_sqr (v:Number):Number {			return v*v;		}				public function fn_log10 (v:Number):Number {			if (v <= 0) return 0;			return Math.log(v)/Math.log(10);		}				public function fn_sign (v:Number):Number {			if (v > 0) return 1;			if (v < 0) return -1;			return 0;		}				public function fn_sigmoid (v:Number, v2:Number):Number {			//			// compute sigmoid function			// 			// sigmoid(x) = 1 / (1 + e^(-a * x)			//			// where x=v, a=v2			return 1.0 / (1.0 + Math.pow(Math.E,(-1 * v2 * v)));		}				public function fn_rand (v:Number):Number {			return Math.floor(Math.random()*v + 0.5);		}				public function fn_bor (v:Number,v2:Number):Number {			if ((v != 0) || (v2 != 0)) {				return 1.0;			}			else return 0.0		}				public function fn_bnot (v:Number):Number {			if (v == 0) return 1;			return 0;		}						public function fn_if (v:Number,v2:Number,v3:Number):Number {			if (v != 0) return v2;			return v3;		}				public function fn_equal (v:Number,v2:Number):Number {			if (Math.abs(v - v2) < 0.001) return 1;			return 0;		}				public function fn_above (v:Number,v2:Number):Number {			if (v > v2) return 1;			return 0;		}				public function fn_below (v:Number,v2:Number):Number {			if (v < v2) return 1;			return 0;		}				public function fn_band (v:Number, v2:Number):Number {			if ((v != 0) && (v2 != 0)) return 1;			return 0;		}				public function fn_pow (v:Number,v2:Number):Number {			if (v < 0) {				if (v2 > 0) v2 = Math.floor(v2+0.5);				if (v2 < 1) return 1;				return Math.pow(v,v2);			}			return Math.pow(v,v2);		}	}}