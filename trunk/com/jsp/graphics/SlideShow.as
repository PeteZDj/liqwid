/*       *      Copyright 2009 (c) Scott Penberthy, scottpenberthy.com. All Rights Reserved. *       *      This software is distributed under commercial and open source licenses. *      You may use the GPL open source license described below or you may acquire  *      a commercial license from scottpenberthy.com. You agree to be fully bound  *      by the terms of either license. Consult the LICENSE.TXT distributed with  *      this software for full details. *       *      This software is open source; you can redistribute it and/or modify it  *      under the terms of the GNU General Public License as published by the  *      Free Software Foundation; either version 2 of the License, or (at your  *      option) any later version. See the GNU General Public License for more  *      details at: http://scottpenberthy.com/legal/gplLicense.html *       *      This program is distributed WITHOUT ANY WARRANTY; without even the  *      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *       *      This GPL license does NOT permit incorporating this software into  *      proprietary programs. If you are unable to comply with the GPL, you must *      acquire a commercial license to use this software. Commercial licenses  *      for this software and support services are available by contacting *      scott.penberthy@gmail.com. * */  // TODO - The timing of things is a bit flakey here and needs coordination.package com.jsp.graphics{	import flash.display.BitmapData;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.TimerEvent;	import flash.utils.Timer;	import flash.utils.getTimer;	public class SlideShow extends Sprite	{		private var _wipe:SmpteWipe;					// The wipe effect		private var _pics:Array;						// Array of objects with {source: url, image: <a picture obj>		private var _timer:Timer;						// Timer for watching a slide		private var _t0:Number;							// t0 = system time when timer started		private var _t:Number;							// t = elapsed time in seconds since timer started		private var _state:uint;						// current state of the slideshow		private var _delay:Number;						// number of seconds to delay (watch an image)		private var _pic:Object;						// current image data		private var _pic2:Object;						// next image data		private var _raw:BitmapData;					// raw bitmap, for texture mapping				private static const ST_IDLE:uint = 0;		private static const ST_SHOW:uint = 1;		private static const ST_WIPE:uint = 2;		private static const ST_LOAD:uint = 3;		private static const ST_STOP:uint = 4;				public function SlideShow(pics:Array, delay:Number=10, random:Boolean = true)		{			super();			_pics = pics;			_state = ST_IDLE;			_raw = null;			_timer = new Timer(100);			_timer.addEventListener(TimerEvent.TIMER, tic);			_delay = delay;			if (random) randomize();		}				private function randomize():void {			// Use the Fisher-Yates algorithm for shuffling the _pics array						var j:int;			var obj:Object;			var i:int;						for (i=_pics.length; i > 0; j = Math.floor(Math.random()*i), obj=_pics[--i], _pics[i] = _pics[j], _pics[j] = obj);		}				//		// External API		//		// var s:SlideShow = new SlideShow(pics,delay);		//		// s.raw - return the raw bitmapdata, for texture mapping		// s.delay=n - set the delay between slides for N seconds		// s.start() - (re)start the slideshow		// s.stop() - stop the slideshow		//				public function get raw():BitmapData {			return _raw;		}				public function set delay(n:Number):void {			if (n < 2) n = 2;			_delay = n;		}				public function start():void {			if (_state != ST_IDLE && _state != ST_STOP) {				//trace("Ignoring start, cuz we're in state "+_state);				return;			}			trace("**Starting slide show");			_state = ST_IDLE;			if (!_pic) _pic = _pics.shift();			load();		}				public function stop():void {			if (_state != ST_IDLE) _state = ST_STOP;		}				private function load():void {			_state = ST_LOAD;			if (_pic.image) {				show();			}			else {				trace("Loading "+_pic.source);				_pic.image = new Picture(_pic.source);				_pic.image.addEventListener(Event.COMPLETE, gotPic);				_pic.image.load();				// TODO - add a timer here to move on if the picture doesn't exist			}		} 				private function gotPic(e:Event):void {			var p:Picture = e.target as Picture;			p.removeEventListener(Event.COMPLETE, gotPic);			_raw = _pic.image.raw;			if (_state != ST_STOP) show();		}				private function show():void {			_t0 = getTimer();			_t = 0;			_state = ST_SHOW;			_timer.start();		}				private function tic(e:TimerEvent):void {			_t = (getTimer() - _t0)*0.001;			switch (_state) {								case ST_SHOW:					if (_t >= _delay) next();					break;									case ST_STOP:					_timer.stop();					_state = ST_IDLE;					break;									default:					// do nothing;			}		}				private function next():void {						_pics.push(_pic);			_pic2 = _pics.shift();			//trace("Slideshow grabbing raw pic "+_pic2.source);						if (_pic2.image) {				//trace("**using cached pic in slideshow");				wipe();			}			else {				_pic2.image = new Picture(_pic.source);				_pic2.image.addEventListener(Event.COMPLETE, gotNextPic);				_state = ST_LOAD;				_timer.stop();				_pic2.image.load();				// TODO - add a timer here to move on if the picture doesn't exist			}		}				private function gotNextPic(e:Event):void {			var p:Picture = e.target as Picture;			p.removeEventListener(Event.COMPLETE, gotNextPic);			if (_state == ST_LOAD && _pic && _pic2 && _pic.image && _pic2.image) {				//trace("Slideshow loaded "+_pic2.source);				//if (_pic.image.raw == null) trace("... but we're missing the current image!  weird.");				//if (_pic2.image.raw == null) trace("... but we're missing the NEW image!  weird.");				wipe();			}			else {				// the picture came in after we needed it.				p.raw.dispose();			}		}				private function wipe():void {			var w2:EdgeWipe = new EdgeWipe({source: _pic.image.raw, target: _pic2.image.raw});						useWipe(w2);			chooseTransition();						_state = ST_WIPE;			_wipe.start(2);		}				private function useWipe(w:SmpteWipe):void {			_raw = w.raw;			if (_wipe) _wipe.dispose();			_wipe = w;			_wipe.addEventListener(Event.COMPLETE, wipeDone);		}				private function chooseTransition():void {			var effects:Array = [1,2,3,4,5,6,41,42,46,21,22,7,23,24,25,26,41,42,43,45,46,61,62,63,64];			var smpte:Number = effects[Math.floor(Math.random()*effects.length)];			_wipe.chooseEffect(smpte);			_wipe.repeat(Math.random()*4, Math.random()*4);			_wipe.direction = (Math.random() > 0.5) ? 1 : -1;		}				private function wipeDone(e:Event):void {			_raw = _wipe.raw;			_pic.image.raw.dispose();			_pic.image = null;			_pic = _pic2;			_pic2 = null;			if (_state != ST_STOP) show();		}			}}