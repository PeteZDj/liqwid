/*       *      Copyright 2009 (c) Scott Penberthy, scottpenberthy.com. All Rights Reserved. *       *      This software is distributed under commercial and open source licenses. *      You may use the GPL open source license described below or you may acquire  *      a commercial license from scottpenberthy.com. You agree to be fully bound  *      by the terms of either license. Consult the LICENSE.TXT distributed with  *      this software for full details. *       *      This software is open source; you can redistribute it and/or modify it  *      under the terms of the GNU General Public License as published by the  *      Free Software Foundation; either version 2 of the License, or (at your  *      option) any later version. See the GNU General Public License for more  *      details at: http://scottpenberthy.com/legal/gplLicense.html *       *      This program is distributed WITHOUT ANY WARRANTY; without even the  *      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *       *      This GPL license does NOT permit incorporating this software into  *      proprietary programs. If you are unable to comply with the GPL, you must *      acquire a commercial license to use this software. Commercial licenses  *      for this software and support services are available by contacting *      scott.penberthy@gmail.com. * */package com.jsp.graphics{	import flash.display.BitmapData;	import flash.display.Graphics;	import flash.display.Sprite;	import flash.geom.Matrix;	public class uvSprite extends Sprite	{		//		// Cache some key values to reduce the number of multiplications and divisions		// that occur when texture mapping		//		protected var _w:Number;		protected var _w2:Number;		protected var _iw:Number;				protected var _h:Number;		protected var _h2:Number;		protected var _ih:Number;				protected var _aspect:Number;		protected var _iaspect:Number;				protected var _tMat:Matrix;		protected var _sMat:Matrix;				public function uvSprite(width:Number, height:Number)		{			_w = (width < 1) ? 1 : width;			_h = (height < 1) ? 1 : height;			_w2 = _w/2;			_h2 = _h/2;			_iw = 1/_w;			_ih = 1/_h;			_aspect = _w/_h;			_iaspect = 1/_aspect;			_tMat = new Matrix();			_sMat = new Matrix();			super();		}				public function resize(width:Number, height:Number):void {			_w = (width < 1) ? 1 : width;			_h = (height < 1) ? 1 : height;			_w2 = _w/2;			_h2 = _h/2;			_iw = 1/_w;			_ih = 1/_h;			_aspect = _w/_h;			_iaspect = _h/_w;			this.graphics.clear();			afterResize();		}				protected function afterResize():void {			// do local resizing stuff here		}				protected function makeColor(r:Number, g:Number, b:Number, a:Number):uint {			if (r > 1) r=1;			if (g > 1) g=1;			if (b > 1) b=1;			if (a > 1) a=1;			if (r < 0) r=0;			if (g < 0) g=0;			if (b < 0) b=0;			if (a < 0) a=0;			return ((Math.floor(a*255) & 0xFF) << 24) |			       ((Math.floor(r*255) & 0xFF) << 16) |			       ((Math.floor(g*255) & 0xFF) << 8) | 				   (Math.floor(b*255) & 0xFF);		}				protected function unitize(n:Number):Number {			if (n < 0) n = 0;			if (n > 1) n = 1;			return n;		}				protected function alphatize(n:Number):Number {			if (n < 0.03 && n > 0) n = 0.03;			if (n > 1) n = 1;			return n;		}				public function hurlTriangle(texture:BitmapData, dest:Sprite, p0:Pixel, p1:Pixel, p2:Pixel):void {			// 			// Hurl triangle bits onto the zBuffer			//			var _wt:Number = texture.width;			var _ht:Number = texture.height;			var w2:Number = _w2;			var h2:Number = _h2;			var x0:Number = p0.x0;			var y0:Number = p0.y0;			var x1:Number = p1.x0;			var y1:Number = p1.y0;			var x2:Number = p2.x0;			var y2:Number = p2.y0;			var u0:Number = p0.u_t * _wt; 			var v0:Number = p0.v_t * _ht; 			var u1:Number = p1.u_t * _wt; 			var v1:Number = p1.v_t * _ht;			var u2:Number = p2.u_t * _wt;			var v2:Number = p2.v_t * _ht;			var iw:Number = _iw;			var ih:Number = _iaspect * _ih; // 1/(_h*_aspectRatio);			var g:Graphics = dest.graphics;			var show:Boolean = false;						if ((v0 == v1) && (v1 == v2)) show=true;			if ((u0 == u1) && (u1 == u2)) show=true;						if (show && false) {			trace("Triangle " + // (" + i0 + "," + i1 + "," + i2 + ")" + 				  " = " + "(x0=" + x0 + ",y0=" + y0 + ") " +				  "(u0=" + u0 + ",v0=" + v0 + ")\n " +				  "(x1=" + x1 + ",y1=" + y1 + ") " +				  "(u1=" + u1 + ",v1=" + v1 + ")\n " +				  "(x2=" + x2 + ",y2=" + y2 + ") " +				  "(u2=" + u2 + ",v2=" + v2 + ") ");			return;			}			// first, map from the proper location on the texture			// to the screen... without scaling the screen			_tMat.a = (u1 - u0) * iw;			_tMat.b = (v1 - v0) * iw;			_tMat.c = (u2 - u0) * ih;			_tMat.d = (v2 - v0) * ih;			_tMat.tx = u0; //u0; // Math.floor(u0)% _w;			_tMat.ty = v0; // Math.floor(v0)% _h;			_tMat.invert();			// now, scale the screen			_sMat.a = (x1 - x0) * iw;			_sMat.b = (y1 - y0) * iw;			_sMat.c = (x2 - x0) * ih;			_sMat.d = (y2 - y0) * ih;			_sMat.tx = x0;			_sMat.ty = y0;			// concatenate these two transformations into one			// first, texture to screen, then screen to scale & location			_tMat.concat(_sMat);			// draw the triangle and fill with the scaled, translated bitmap			g.moveTo(x0,y0);			g.beginBitmapFill(texture,_tMat,true,true); // to smooth or not to smooth..			g.lineTo(x1,y1);			g.lineTo(x2,y2);			g.lineTo(x0,y0);			g.endFill();		}	}}