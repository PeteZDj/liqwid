/*       *      Copyright 2009 (c) Scott Penberthy, scottpenberthy.com. All Rights Reserved. *       *      This software is distributed under commercial and open source licenses. *      You may use the GPL open source license described below or you may acquire  *      a commercial license from scottpenberthy.com. You agree to be fully bound  *      by the terms of either license. Consult the LICENSE.TXT distributed with  *      this software for full details. *       *      This software is open source; you can redistribute it and/or modify it  *      under the terms of the GNU General Public License as published by the  *      Free Software Foundation; either version 2 of the License, or (at your  *      option) any later version. See the GNU General Public License for more  *      details at: http://scottpenberthy.com/legal/gplLicense.html *       *      This program is distributed WITHOUT ANY WARRANTY; without even the  *      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *       *      This GPL license does NOT permit incorporating this software into  *      proprietary programs. If you are unable to comply with the GPL, you must *      acquire a commercial license to use this software. Commercial licenses  *      for this software and support services are available by contacting *      scott.penberthy@gmail.com. * */package com.jsp.graphics{	import com.jsp.audio.Wave;		import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.Sprite;	import flash.display.Stage;	import flash.display.BlendMode;	import flash.events.MouseEvent;	import flash.geom.ColorTransform;	import flash.geom.Point;	import flash.filters.ColorMatrixFilter;	import flash.geom.Rectangle;	public class Frame extends uvSprite	{		public static var MAX_SHAPES:uint = 4;						// max number of shapes in a frame		public var solarize:Boolean = false;		public var lighten:Boolean = false;		public var darken:Boolean = false;		public var invert:Boolean = false;		public var echo:Boolean = false;		public var additive:Boolean = false;						// whether or not waves are "addiive" to the display		public var motionVectors:Boolean = false;					// whether or not to use motion vectors				protected var _shader:Shader;		protected var _raw:BitmapData;		protected var _buffer:BitmapData;		protected var _rect:Rectangle;		protected var _pt:Point;				protected var _wave:Wave;		protected var _border:Border;		protected var _shapes:Array;		protected var _echo:VideoEcho;				private var _w0:Number, _h0:Number;							// remember size during fullscreen switch				private var _decayTransform:ColorTransform = new ColorTransform(0.98,0.98,0.98,0.98,0,0,0,0);		private var _decay:Number;				public function Frame(width:Number, height:Number)		{			super(width,height);			init();		}				private var _bmap:Bitmap;				private function init():void {			_w0 = _w;			_h0 = _h;			_shader = null;			_raw = new BitmapData(_w,_h,true,0x000000);			_buffer = new BitmapData(_w,_h,true,0x000000);			_rect = new Rectangle(0,0,_w,_h);			_pt = new Point();			_wave = new Wave(_w,_h);			_border = new Border(_w,_h);			_echo = new VideoEcho(_w,_h);			_echo.orient = 2;			createShapes();			_bmap = new Bitmap(_raw);			addChild(_bmap);			addEventListener(MouseEvent.CLICK, gotClick);		}				private function createShapes():void {			_shapes = new Array(MAX_SHAPES);			for (var i:uint=0; i < MAX_SHAPES; i++) {				_shapes[i] = new uvPolygon(_w,_h);			}		}				public function useShader(s:Shader):void {			_shader = s;		}				public function get raw():BitmapData {			return _raw;		}				public function get buffer():BitmapData {			return _buffer;		}				public function set wrapTexture(how:Boolean):void {			if (_shader) _shader.wrapTexture = how;		}				public function get wrapTexture():Boolean {			if (_shader) return _shader.wrapTexture;			else return false;		}				public function set decay(n:Number):void {			_decay = unitize(n);			_decayTransform.alphaMultiplier = _decay;			_decayTransform.redMultiplier = _decay;			_decayTransform.greenMultiplier = _decay;			_decayTransform.blueMultiplier = _decay;		}				public function get decay():Number {			return _decay;		}				public function get wave():Wave {			return _wave;		}				public function get border():Border {			return _border;		}				override protected function afterResize():void {			trace("Resizing frame to "+_w+"x"+_h);			removeChild(_bmap);			_raw.dispose();			_buffer.dispose();			_wave.resize(_w,_h);			_border.resize(_w,_h);			_echo.resize(_w,_h);			_raw = new BitmapData(_w,_h,false,0x000000);			_buffer = new BitmapData(_w,_h,false,0x000000);			_rect = new Rectangle(0,0,_w,_h)			updateShapeSizes();			_bmap = new Bitmap(_raw);			addChild(_bmap);		}				public function onStageResize():void {			var _stage:Stage = stage;            if (_stage.displayState == 'fullScreen') {            	_w0= _w;            	_h0 = _h;            	resize(_stage.stageWidth, _stage.stageHeight);            }            else {            	resize(_w0,_h0);            }		}				private function updateShapeSizes():void {			for (var i:int=0; i < MAX_SHAPES; i++) {				var poly:uvPolygon = _shapes[i];				poly.resize(_w,_h);			}		}				public function shape(n:Number):uvPolygon {			if (n < 0) n = 0;			n = n % MAX_SHAPES;			return _shapes[n];		}				public function clear():void {			_raw.fillRect(_rect, 0x000000);			_buffer.fillRect(_rect, 0x000000);		}				public function render(t:Number = 0):void {			_raw.lock();			buildFrame(t);			applyEffects();			_raw.unlock();		}				private function buildFrame(t:Number = 0):void {			_buffer.colorTransform(_rect,_decayTransform);			if (additive) trace("** DRAWING ADDITIVE WAVE");			_buffer.draw(_wave,null,null, additive ? BlendMode.ADD: BlendMode.NORMAL);			renderShapes();			_border.render();			_buffer.draw(_border);			if (_shader) {				_shader.run(t);				if (motionVectors) _shader.drawMotionVectors(_buffer);				_raw.copyPixels(_buffer,_rect,_pt);				_shader.textureMap(_raw, _buffer);			}			_buffer.draw(_border);			if (echo) {				_echo.echo(_raw,_buffer);  // we may need one more copy.  ugh.				//_buffer.copyPixels(_raw,_rect,_pt);			}			_raw.copyPixels(_buffer,_rect,_pt);		}		private function applyEffects():void {			if (solarize) solarizeEffect();			if (lighten) lightenEffect();			if (darken) darkenEffect();			if (invert) invertEffect();		}		private function renderShapes():void {					for (var i:int=0; i < MAX_SHAPES; i++) {				var poly:uvPolygon = _shapes[i];				if (poly.active) {					poly.render();					_buffer.draw(poly);				}			}		}					public function toggleFullScreen():void {			var _stage:Stage = stage;			//trace("Toggling display state from "+_stage.displayState);            switch(_stage.displayState) {                case "normal":                    stage.displayState = "fullScreen";                    break;                case "fullScreen":                default:                    stage.displayState = "normal";                    break;			}        }        private function gotClick(e:MouseEvent):void {        	toggleFullScreen();        }				private function solarizeEffect():void {			//			// Provide a "solarized" effect on the current frame			//			// First, invert image			// then multiply it with the original			_raw.draw(_buffer,null,null,"invert");			_raw.draw(_buffer,null,null,"multiply");		}				private function invertEffect():void {			_raw.draw(_buffer,null,null,"invert");		}				private var _darkMat:Array = [1,0,0,0,-25,0,1,0,0,-25,0,0,1,0,-25,0,0,0,1,0];		private var _darkenCMF:ColorMatrixFilter = new ColorMatrixFilter(_darkMat);		private function darkenEffect():void {			// darken an image by 25%			_raw.applyFilter(_buffer, _rect, _pt, _darkenCMF);		}				private var _liteMat:Array = [1,0,0,0,55,0,1,0,0,55,0,0,1,0,55,0,0,0,1,0];		private var _liteCMF:ColorMatrixFilter = new ColorMatrixFilter(_liteMat);		private function lightenEffect():void {			// lighten an image by 55%			_raw.applyFilter(_buffer, _rect, _pt, _liteCMF);		}					public function set echoZoom(n:Number) {			_echo.zoom = n;		}				public function get echoZoom():Number {			return _echo.zoom;		}				public function get echoOrient():Number {			return _echo.orient;		}				public function set echoOrient(n:Number) {			_echo.orient = n;		}				public function get echoAlpha():Number {			return _echo.alpha;		}				public function set echoAlpha(n:Number) {			_echo.alpha = unitize(n);		}			}}