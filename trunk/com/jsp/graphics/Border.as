/*       *      Copyright 2009 (c) Scott Penberthy, scottpenberthy.com. All Rights Reserved. *       *      This software is distributed under commercial and open source licenses. *      You may use the GPL open source license described below or you may acquire  *      a commercial license from scottpenberthy.com. You agree to be fully bound  *      by the terms of either license. Consult the LICENSE.TXT distributed with  *      this software for full details. *       *      This software is open source; you can redistribute it and/or modify it  *      under the terms of the GNU General Public License as published by the  *      Free Software Foundation; either version 2 of the License, or (at your  *      option) any later version. See the GNU General Public License for more  *      details at: http://scottpenberthy.com/legal/gplLicense.html *       *      This program is distributed WITHOUT ANY WARRANTY; without even the  *      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *       *      This GPL license does NOT permit incorporating this software into  *      proprietary programs. If you are unable to comply with the GPL, you must *      acquire a commercial license to use this software. Commercial licenses  *      for this software and support services are available by contacting *      scott.penberthy@gmail.com. * */package com.jsp.graphics{	import flash.display.Graphics;	import flash.filters.BlurFilter;	public class Border extends uvSprite	{		public var ob_size:Number;						// outer border size, 0-1		public var ob_r:Number;							// outer border, red component 0-1		public var ob_g:Number;							// outer border, green component 0-1		public var ob_b:Number;							// outer border, blue component 0-1		public var ob_a:Number;							// outer border, alpha component 0-1				public var ib_size:Number;						// inner border size, 0-1		public var ib_r:Number;							// inner border, red component 0-1		public var ib_g:Number;							// inner border, green component 0-1		public var ib_b:Number;							// inner border, blue component 0-1		public var ib_a:Number;							// inner border, alpha component 0-1				public var blur:Number;							// blur 0-1		private var _blurFilter:BlurFilter = new BlurFilter();		private var _filters:Array; 				private var _bx:Array = new Array(4);		private var _by:Array = new Array(4);				public function Border(width:Number, height:Number)		{			super(width,height);			_filters = [_blurFilter];			init();		}				private function init():void {			ob_r = ob_g = ob_b = 1.0;			ib_r = ib_g = ib_b = 1.0;			ob_size = ib_size = 0.1;						ob_a = ib_a = 0;  // no borders by default		}				public function inner(red:Number, green:Number, blue:Number, alpha:Number = 1.0, size:Number = 0.1):void {			ib_r = red;			ib_g = green;			ib_b = blue;			ib_a = alpha;			ib_size = size;				}				public function outer(red:Number, green:Number, blue:Number, alpha:Number = 1.0, size:Number = 0.1):void {			ob_r = red;			ob_g = green;			ob_b = blue;			ob_a = alpha;			ob_size = size;		}				private function fixSize(n:Number) {			return (n <= 0) ? 0 : Math.max(n,(1/_w2));		}				public function render():void {			var outer:Number = fixSize(ob_size);			var inner:Number = fixSize(ib_size); 			var innerRad:Number, outerRad:Number;			var g:Graphics = this.graphics;			var cos90:Number = Math.cos(0.5*Math.PI);			var sin90:Number = Math.sin(0.5*Math.PI);			var color:uint, aa:Number;						g.clear();			for (var it:int=0; it<2; it++) {				if (it == 0) {				  color = makeColor(ob_r,ob_g,ob_b,1.0);				  innerRad = 1.0 - outer;				  outerRad = 1.0;				  aa = alphatize(ob_a);				}				else {				  color = makeColor(ib_r,ib_g,ib_b,1.0);				  innerRad = 1.0 - outer - inner;				  outerRad = 1.0 - outer;				  aa = alphatize(ib_a);				}				if (aa < 0.01) continue;				_bx[0]=innerRad;				_bx[1]=outerRad;				_bx[2]=outerRad;				_bx[3]=innerRad;				_by[0]=innerRad;				_by[1]=outerRad;				_by[2]=-outerRad;				_by[3]=-innerRad;								for (var rot:int=0; rot < 4; rot++) {					drawBorderEdge(g,color,aa);					for (var j:int=0; j<4; j++) {						var ox:Number = _bx[j];						var oy:Number = _by[j];						_bx[j] = ox*cos90 - oy*sin90;						_by[j] = ox*sin90 + oy*cos90;					}				}			}			doEffects();		}				private function doEffects():void {			if (blur > 0) {				_blurFilter.blurX = blur*50;				_blurFilter.blurY = blur*50;				this.filters = _filters;			}			else {				this.filters = null;			}		}				private function borderX(i:uint):Number {			// _bx[i] is -1 to +1 centered at w2,h2			return _w2 - _bx[i]*_w2;		}				private function borderY(i:uint):Number {			// _by[i] is -1 to +1 centered at w2,h2			return _h2 + _by[i]*_h2;		}				private function drawBorderEdge(g:Graphics, color:uint, alpha:Number):void {			g.beginFill(color,alpha);			g.moveTo(borderX(0),borderY(0));			for (var i:int=1; i < 4; i++) {				g.lineTo(borderX(i),borderY(i)); 			}			g.lineTo(borderX(0),borderY(0));			g.endFill();		}			}}