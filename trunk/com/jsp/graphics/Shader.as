/*       *      Copyright 2009 (c) Scott Penberthy, scottpenberthy.com. All Rights Reserved. *       *      This software is distributed under commercial and open source licenses. *      You may use the GPL open source license described below or you may acquire  *      a commercial license from scottpenberthy.com. You agree to be fully bound  *      by the terms of either license. Consult the LICENSE.TXT distributed with  *      this software for full details. *       *      This software is open source; you can redistribute it and/or modify it  *      under the terms of the GNU General Public License as published by the  *      Free Software Foundation; either version 2 of the License, or (at your  *      option) any later version. See the GNU General Public License for more  *      details at: http://scottpenberthy.com/legal/gplLicense.html *       *      This program is distributed WITHOUT ANY WARRANTY; without even the  *      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *       *      This GPL license does NOT permit incorporating this software into  *      proprietary programs. If you are unable to comply with the GPL, you must *      acquire a commercial license to use this software. Commercial licenses  *      for this software and support services are available by contacting *      scott.penberthy@gmail.com. * */ package com.jsp.graphics{	import com.jsp.calculator.Calculator;	import com.jsp.calculator.Milk;		//	// Shader	//	// A simple pixel shader	//		public class Shader extends Mesh	{		private var _c:Calculator;		private var _p:String;		private var _b:Array;		private var _argCount:uint;		private var _pixelInit:Array;		private var _defaults:Array;		private var _frameEnd:uint;		private var _pixelEnd:uint;				private static const ARGS:Array = 		['zoom','zoom_exp','cx','cy','rot','sx','sy','dx','dy',		 'warp', 'warp_speed', 'warp_scale','u_t','v_t', 		 'u','v','x','y','ang','rad'];				public function Shader(rows:int, cols:int, width:Number, height:Number)		{			super(rows, cols, width, height);			_c = new Calculator();			_b = _c.makeFunctionBlock(ARGS);			_defaults = new Array();			_argCount = ARGS.length;					// cache the length calculation			_frameEnd = ARGS.indexOf('warp_scale');		// vars up to here are copied from frame			_pixelEnd = ARGS.indexOf('v_t');			// vars up to here are written to a pixel			savePixelInitValues();		}				private function savePixelInitValues():void {			_pixelInit = new Array(_mesh.length);			for (var i:uint=0; i < _mesh.length; i++) {				var p:Pixel = _mesh[i];				_pixelInit[i] = {x: p.x, y: p.y, ang: p.ang, rad: p.rad};			}		}				public function storeProgram(p:String):void {			trace("Using Shader preset: "+p);			_p = p;			super.reset();			_c.clear();			_c.load(p);			_b = _c.makeFunctionBlock(ARGS);		}				public function storeCodes(codes:Array):void {			_p = null;			super.reset();			//_c.clear();			_c.bytecodes = codes;			_b = _c.makeFunctionBlock(ARGS);		}				public function get memory():Array {			return _c.memory;		}		public function run(time:Number):void {			var len:Number = _mesh.length;			//var toShow:Number = Math.floor(Math.random()*len);			var mv:Pixel;			var init:Object;						createDefaults(time);			if (_c.lookup('q8')) trace('q8='+_c.lookup('q8'));			for (var i:int=0; i<len; i++) {			  mv = _mesh[i];			  init = _pixelInit[i];			  mv.x = init.x;			  mv.y = init.y;			  mv.ang = init.ang;			  mv.rad = init.rad;			  readPixel(mv);			  _c.call(_b);			  writePixel(mv);			 // if (i == toShow) trace(mv);			}			morph(time);		}				public function store(name:String, value:Number):void {			_c.store(name, value);		}				public function lookup(name:String):Number {			return _c.lookup(name);		}				private function createDefaults(time:Number):void {			var m:Array = _c.memory;			_c.store('time',time);			for (var i:int=0; i <= _frameEnd; i++) {				var bi:Object = _b[i];				_defaults[i] = m[bi.id];			}		}				private function readPixel(mv:Pixel):void {			//			// Fill the calculator call block with all the values from the current Pixel			//			var len:int = _b.length;			var j:int=0;						// First copy the values from the frame to the calculator			for (var i:int=0; i <= _frameEnd; i++) {				var bi:Object = _b[i];				bi.value = _defaults[i];			}						// Now copy the other values from the pixel to the calculator			for (; i < _argCount; i++) {				bi = _b[i];				bi.value = mv[bi.name];			}		}				private function writePixel(mv:Pixel):void {			//			// Update the Pixel with values from our calculator			//			for (var i:int=0; i <= _pixelEnd; i++) {				var bi:Object = _b[i];				mv[bi.name] = bi.value;			}		}			}}