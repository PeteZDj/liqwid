/*       *      Copyright 2009 (c) Scott Penberthy, scottpenberthy.com. All Rights Reserved. *       *      This software is distributed under commercial and open source licenses. *      You may use the GPL open source license described below or you may acquire  *      a commercial license from scottpenberthy.com. You agree to be fully bound  *      by the terms of either license. Consult the LICENSE.TXT distributed with  *      this software for full details. *       *      This software is open source; you can redistribute it and/or modify it  *      under the terms of the GNU General Public License as published by the  *      Free Software Foundation; either version 2 of the License, or (at your  *      option) any later version. See the GNU General Public License for more  *      details at: http://scottpenberthy.com/legal/gplLicense.html *       *      This program is distributed WITHOUT ANY WARRANTY; without even the  *      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *       *      This GPL license does NOT permit incorporating this software into  *      proprietary programs. If you are unable to comply with the GPL, you must *      acquire a commercial license to use this software. Commercial licenses  *      for this software and support services are available by contacting *      scott.penberthy@gmail.com. * */package com.jsp.graphics{	import flash.geom.Point;		public class Pixel	{		/**		 * A MeshVertex represents a point on a 2D surface.  These points are connected		 * via straight lines to form a grid that overlays the surface.  Each point		 * corresponds to a (u,v) coordinate on an underling texture, and an (x,y)		 * point on the screen.		 * 		 * By manipulating (u,v) and (x,y), we can create many perspective and graphical		 * effects.		 *		 * We also store several values at a vertex for running computations, a crude		 * version of pixel shaders.		 *  		 **/		 		public var u:Number, v:Number;			// (u,v) starting texture location in [0,1] space		public var x:Number, y:Number;			// (x,y) starting location in [-1,1] space for computations				public var u_t:Number, v_t:Number;		// (u_t,v_t) texture location at time t		public var x_t:Number, y_t:Number;		// (x_t,y_t) screen location at time t						public var x0:Number, y0:Number;		// (x,y) location on the screen for drawing		public var rad:Number, ang:Number;		// (rad,ang) location in polar coordinates 		public var i:Number;					// vertex number (0...n)				//		// effects		//		// We apply the following effects, in order:		//		// 1. Zoom the pixel  zoom^(radius^zoom_exp)		// 2. Scale the pixel sx in the x direction, sy in the y direction		// 3. Warp the pixel in a wave form, based on time		// 4. Rotate the pixel rot radians around the center (cx,cy) in uv space		// 5. Translate the pixel sx in the x direction, sy in the y direction in uv space		// 6. Chop the pixel to [0,1] in x and y if wrapping is not enabled		//				public var wrap:Boolean = true;			// whether to wrap our transformations			public var zoom:Number = 1.0;			// amount to zoom this pixel		public var zoom_exp:Number = 1.0;		// zoom exponent		public var cx:Number = 0.5;				// center x location for rotations, uv space		public var cy:Number = 0.5;				// center y location for rotations, uv space		public var rot:Number = 0.0;			// how much to rotate the pixel around the center		public var sx:Number = 1.0;				// x scaling factor		public var sy:Number = 1.0;				// y scaling factor		public var dx:Number = 0.0;				// how much to shift the pixel in the x direction, uv units		public var dy:Number = 0.0;				// how much to shift the pixel in the y direction, uv units				public var warp:Number = 0.0;			// warp scaling factor		public var warp_speed:Number = 1.0;		// how fast to warp the vertex		public var warp_scale:Number = 2.0;		// how much to scale the warp effect				public var q:Array;			 			// shared variables, passed between pixels								public static var warpedTime:Number = 0.0;		public static var iwscale:Number = 1.0;	// 1/warp scale for warp effects				public static var f0:Number = 0.0;		// shared constant for warp effects		public static var f1:Number = 0.0;		// shared constant for warp effects		public static var f2:Number = 0.0;		// shared constant for warp effects		public static var f3:Number = 0.0;		// shared constant for warp effects		private static var _lastWarpTime:Number = -1; // current time used for warp effects					public function Pixel(u:Number, v:Number, x:Number, y:Number)		{			this.u = u_t = u;			this.v = v_t = v;			this.x = x_t = x;			this.y = y_t = y;			init();		}				public function reset():void {			// reset all attributes to default values			u_t = u;			v_t = v;			x_t = x;			y_t = y;			sy = sx = 1.0;			dx = dy = 0.0;			warp = 0; warp_speed = 1.0; warp_scale = 1.0;			zoom = 1; zoom_exp = 0;			wrap = true;			rot = 0;			cx = cy = 0.5;			clearq();		}				public function clearq():void {			for (var i:int=0; i < 9; i++) {				q[i] = 0.0;			}		}				private function init():void {			i = 0;			rad = Math.sqrt(x*x+y*y);			ang = Math.atan2(-y, x);			if (ang < 0) ang += 2*Math.PI;			q = new Array(9);			clearq();		}				public function morph(time:Number):void {			//			// Parametrically morph the (u,v) coordinates based on time			// to compute (u_t,v_t);			//			doZoom();			stretch();			doWarp(time);			rotate();			translate();			chop();		}				public function t0():void {			u_t = u;			v_t = v;			x_t = x;			y_t = y;		}				public function doZoom():void {			var p1:Number = (zoom_exp > 0) ? Math.pow(zoom_exp, rad*2 - 1) : 1.0;			var p0:Number = zoom;			var p2:Number = Math.pow(p0,p1);			var iZoom:Number =  (p2 == 0) ? 1.0 : 1.0/p2;						u_t = (u - 0.5)*iZoom + 0.5;			v_t = (v - 0.5)*iZoom + 0.5;						//u_t = x*0.5*iZoom + 0.5;			//v_t = y*0.5*iZoom + 0.5;		}				public function stretch():void {			// stretch			if (sx != 0) u_t = (u_t - cx)/sx + cx;			if (sy != 0) v_t = (v_t - cy)/sy + cy;		}				public function doWarp(time:Number):void {			if (warp == 0.0) return;			if (time != _lastWarpTime) updateWarpFactors(time);			u_t += warp*0.0035*Math.sin(warpedTime*0.333 + iwscale*(x*f0 - y*f3));			v_t += warp*0.0035*Math.cos(warpedTime*0.375 + iwscale*(x*f2 - y*f1));			u_t += warp*0.0035*Math.cos(warpedTime*0.753 + iwscale*(x*f1 - y*f2));			v_t += warp*0.0035*Math.sin(warpedTime*0.825 + iwscale*(x*f0 - y*f3));			}				public function rotate():void {			//			// Rotate the point (u,v) about the center (cx,cy) a total of ROT radians			//			var u2:Number = u_t - cx;			var v2:Number = v_t - cy;			var cos_rot:Number = Math.cos(rot);			var sin_rot:Number = Math.sin(rot);			 			u_t = u2*cos_rot - v2*sin_rot + cx;			v_t = u2*sin_rot + v2*cos_rot + cy;		}				public function translate():void {			// translation:			var offset:Number = 0.001;  // ~1/1024			u_t -= dx - offset;			v_t -= dy - offset;		}				public function chop():void {			if (wrap) return;			if (u_t < 0) u_t = leftChop(u_t);			if (v_t < 0) v_t = leftChop(v_t);			if (u_t > 1) u_t = rightChop(u_t);			if (v_t > 1) v_t = rightChop(v_t);		}				private function leftChop(n:Number):Number {			var i:int = Math.floor(n*-1);			return 1.0-(n+i);		}				private function rightChop(n:Number):Number {			var i:int = Math.floor(n);			return (n-i);		}				private function updateWarpFactors(time:Number):void {			//			// In Milkdrop, these warp factors are across the entire mesh vs.			// in each pixel.  Hmm.  Here, the first pixel with a warp factor			// defines it for all other vertices in the world.  Broken.			//			// 			// We should pull this out into a mesh, or something higher level,			// since it applies to agroup.			//			warpedTime = time * warp_speed;			iwscale = 1.0;			if (warp_scale != 0) {			     iwscale = 1.0/warp_scale;			}			f0 = 11.68 + 4.0*Math.cos(warpedTime*1.413 + 10);			f1 =  8.77 + 3.0*Math.cos(warpedTime*1.113 + 7);			f2 = 10.54 + 3.0*Math.cos(warpedTime*1.233 + 3);			f3 = 11.49 + 4.0*Math.cos(warpedTime*0.933 + 5);						_lastWarpTime = time;		}	}}