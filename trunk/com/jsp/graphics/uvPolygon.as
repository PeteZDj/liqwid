/*       *      Copyright 2009 (c) Scott Penberthy, scottpenberthy.com. All Rights Reserved. *       *      This software is distributed under commercial and open source licenses. *      You may use the GPL open source license described below or you may acquire  *      a commercial license from scottpenberthy.com. You agree to be fully bound  *      by the terms of either license. Consult the LICENSE.TXT distributed with  *      this software for full details. *       *      This software is open source; you can redistribute it and/or modify it  *      under the terms of the GNU General Public License as published by the  *      Free Software Foundation; either version 2 of the License, or (at your  *      option) any later version. See the GNU General Public License for more  *      details at: http://scottpenberthy.com/legal/gplLicense.html *       *      This program is distributed WITHOUT ANY WARRANTY; without even the  *      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *       *      This GPL license does NOT permit incorporating this software into  *      proprietary programs. If you are unable to comply with the GPL, you must *      acquire a commercial license to use this software. Commercial licenses  *      for this software and support services are available by contacting *      scott.penberthy@gmail.com. * */package com.jsp.graphics{	import flash.display.BitmapData;	import flash.display.GradientType;	import flash.display.Graphics;	import flash.display.Sprite;	import flash.geom.Matrix;	public class uvPolygon extends Sprite	{						public var rad:Number=0.1;								// shape radius		public var ang:Number=0;								// angle of rotation, in radians		public var sides:Number = 4;							// number of sides		public var progress:Number;		public var u0:Number;									// (u,v) coordinate of center		public var v0:Number;		public var tex_zoom:Number = 1;							// zoom amount on texture		public var tex_angle:Number = 0;						// rotation angle on texture		public var r:Number, g:Number, b:Number, a:Number;		// inner color		public var r2:Number, g2:Number, b2:Number, a2:Number;	// outer color		public var 	border_r:Number, 							// border color					border_g:Number, 					border_b:Number, 					border_a:Number;		public var textured:Boolean = false;		public var active:Boolean = false;		public var thick:Boolean = false;		private var _raw:BitmapData;							// raw bitmapdata for sampling 		private var _wt:Number;									// size w_t x h_t of texture		private var _ht:Number;				private static var MAX_SIDES:uint = 101;		private var _w:Number;									// width, height of target canvas		private var _h:Number;		private var _w2:Number;		private var _h2:Number;		private var _aspect:Number;								// aspect ratio of canvas				private var _shapeMat:Matrix = new Matrix();		private var _mesh:Array = new Array(MAX_SIDES); 	// use a constant, please!				public function uvPolygon(width:Number, height:Number)		{			_w = width;			_h = height;			init();		}				private function init():void {			_aspect = (_h > 0) ? _w/_h : 1;			// we could be smarter about this...			for (var i:uint=0; i < MAX_SIDES; i++) {				_mesh[i] = null;			}			textured = false;			_raw = null;			_w2 = _w/2;			_h2 = _h/2;			progress = 0;		}				public function useTexture(b:BitmapData):void {			_raw = b;			_wt = b.width;			_ht = b.height;			textured = true;		}				public function get raw():BitmapData {			return _raw;		}				public function inner(red:Number, green:Number, blue:Number, alpha:Number = 1.0):void {			r = red;			g = green;			b = blue;			a = alpha;		}				public function outer(red:Number, green:Number, blue:Number, alpha:Number = 1.0):void {			r2 = red;			g2 = green;			b2 = blue;			a2 = alpha;		}				public function border(red:Number, green:Number, blue:Number, alpha:Number = 1.0):void {			border_r = red;			border_g = green;			border_b = blue;			border_a = alpha;		}				public function uv(u:Number, v:Number):void {			u0 = u;			v0 = v;		}				public function resize(width:Number, height:Number):void {			_w = width;			_h = height;			_w2 = _w/2;			_h2 = _h/2;			_aspect = (_h == 0) ? 1.0 : _w/_h;			this.graphics.clear();		}				public function render():void {			if (sides < 3) centeredMesh();			else updateMesh();						if (textured) renderTextured();			else renderPlain();		}				private function centeredMesh():void {			var v_height:Number = Math.max(rad,0.2);			var u_width:Number = v_height / _aspect;			var u_offset:Number = (1 - u_width)/2;			var v_offset:Number = (1 - v_height)/2;			var iTexZoom:Number = (tex_zoom == 0) ? 1.0 : 1.0/tex_zoom;			var p:Pixel;						var z2:Number = iTexZoom; //*(1/(0.8+Math.random()*0.4));			for (var i:int=0; i < 4; i++) {				p = _mesh[i];				p = p ? p : new Pixel(0,0,0,0);				switch (i) {					case 0:						p.x0 = Math.floor(u_offset*_w);						p.y0 = Math.floor(v_offset*_h);						p.u = (u0+u_offset)*z2;						p.v = (v0+v_offset)*z2;						break;										case 1:						p.x0 = Math.floor(_w*(u_offset + u_width));						p.y0 = Math.floor(v_offset*_h);						p.u = (u0+u_offset + u_width)*z2;						p.v = (v0+v_offset)*z2;						break;											case 2:						p.x0 = Math.floor(u_offset*_w);						p.y0 = Math.floor(_h*(v_offset + v_height));						p.u = (u0+u_offset)*z2;						p.v = (v0 + v_offset + v_height)*z2;						break;											case 3:						p.x0 = Math.floor(_w*(u_offset + u_width));						p.y0 = Math.floor(_h*(v_offset + v_height));						p.u = (u0 + u_offset + u_width)*z2;						p.v = (v0 + v_offset + v_height)*z2;						break;				}				_mesh[i] = p;			}		}					private function updateMesh():void {			// info contains all the shape information			// that we should draw			//			// we fill up _shapeVert with vertices for the shape where			//   _shapeVert[0] = center			//   _shapeVert[1] - _shapeVert[N] = vertices 1-N of the shape			//			// the vertices store (x0,y0) as the absolute screen coordinates, and			// (u,v) as the uv coordinates for a texture in -1,1 space			//			var radius:Number = rad/2;			var angle:Number = ang;			var sh_x:Number = u0 % 1;			var sh_y:Number = v0 % 1; 			var iTexZoom:Number = (tex_zoom == 0) ? 1.0 : 1.0/tex_zoom;			var tex_rot:Number = tex_angle;			var twoPi:Number = Math.PI * 2;			var tilt:Number = Math.PI * 0.25;			var theta0:Number = angle + tilt;			var theta1:Number = tex_rot + tilt;			var dTheta:Number; 			var ix:Number, iy:Number, ox:Number, oy:Number;			var ha:Number = _h*_aspect;			var p:Pixel;						//trace(sides+"-sided shape at ("+sh_x+","+sh_y+") rad="+radius); // ****						if (sides < 3) sides = 3;			if (sides > (MAX_SIDES - 1)) sides = MAX_SIDES-1;			sides = Math.floor(sides);			dTheta = twoPi/Number(sides);			p = _mesh[0];			p = p ? p : new Pixel(0,0,0,0);			p.x0 = sh_x*_w;			p.y0 = sh_y*ha;			p.u = 0.5;			p.v = 0.5;			_mesh[0] = p;			//trace("Shape at ("+p.x0+","+p.y0+") rad="+radius); // ****						p.u = 0.5;			p.v = 0.5;			var r2:Number = radius; // + Math.random()*0.2;			var z2:Number = iTexZoom; //*(1/(0.8+Math.random()*0.4));			for (var i:int=1; i <= sides; i++) {								p = _mesh[i];				p = p ? p : new Pixel(0,0,0,0);				p.x0 = Math.floor((sh_x + r2*Math.cos(theta0))*_w);				p.y0 = Math.floor((sh_y + r2*Math.sin(theta0))*ha);				p.u = 0.5 + 0.4*Math.cos(theta1)*z2;				p.v = 0.5 + 0.4*Math.sin(theta1)*z2*_aspect;				theta0 += dTheta;				theta1 += dTheta;				_mesh[i] = p;			}		}				public function renderPlain():void {			//			// Draw an n-sided shape as described in _shapeVert[]			// with attributes captured in the 'info' state			//			// we fill up _shapeVert with vertices for the shape where			//   _shapeVert[0] = center			//   _shapeVert[1] - _shapeVert[N] = vertices 1-N of the shape			//			// the vertices store (x0,y0) as the absolute screen coordinates, and			// (u,v) as the uv coordinates for a texture in -1,1 space			//			var sides:int = sides;			var radius:Number = rad*0.5;			var innerRGB:uint = makeColor(r,g,b,a);			var outerRGB:uint = makeColor(r2,g2,b2,a2);			var borderRGB:uint = makeColor(border_r,border_g,border_b,border_a);			var g:Graphics = this.graphics;			var p:Pixel;			var m:Matrix = new Matrix();						p = _mesh[0];			//trace(sides+"-sided shape i="+innerRGB.toString(16)+" o="+outerRGB.toString(16));			g.clear();			//g.lineStyle(1,0xFF0000);			g.lineStyle(thick ? 4 : 1,borderRGB,border_a);			//g.beginFill(innerRGB);			m.createGradientBox(radius*_w*2,radius*_h*_aspect*2,0,								p.x0 - radius*_w, p.y0 - radius*_h*_aspect);			//FOO		    g.beginGradientFill(GradientType.RADIAL,[innerRGB,outerRGB],[0,100],[0x00,0xFF],m);			outline(g);			g.endFill();		}				public function outline(g:Graphics):void {			var p:Pixel = _mesh[1];			g.moveTo(p.x0,p.y0);			for (var i:int=2; i <= sides; i++) {				p = _mesh[i];				g.lineTo(p.x0,p.y0);				//trace("x,y="+vert.x0+","+vert.y0);			}			p = _mesh[1];			g.lineTo(p.x0,p.y0);		}				private function hurlPies():void {			var p0:Pixel, p1:Pixel, p2:Pixel;			p0 = _mesh[0];			for (var i:int=1; i < sides; i++) {				p1 = _mesh[i];				p2 = _mesh[i+1];				hurlTriangle(p0,p1,p2);			}			p1 = _mesh[1];			p2 = _mesh[sides]			hurlTriangle(p2,p1,p0);		}				private function hurlSquare():void {			hurlTriangle(_mesh[0],_mesh[1],_mesh[2]);			hurlTriangle(_mesh[1],_mesh[2],_mesh[3]);		}					public function renderTextured():void {			//			// Draw an n-sided shape as described in _shapeVert[]			// with attributes captured in the 'info' state			//			// we fill up _shapeVert with vertices for the shape where			//   _shapeVert[0] = center			//   _shapeVert[1] - _shapeVert[N] = vertices 1-N of the shape			//			// the vertices store (x0,y0) as the absolute screen coordinates, and			// (u,v) as the uv coordinates for a texture in -1,1 space			//			if (!raw) return;						var borderRGB:uint = makeColor(border_r,border_g,border_b,border_a);			var g:Graphics = this.graphics;			var v1:Pixel, v2:Pixel, v3:Pixel, v0:Pixel;			var m:Matrix = new Matrix();						// fill the texture			g.clear();			g.lineStyle();			if (sides > 3) hurlPies();			else hurlSquare();						// now draw border around blt'ed interior			g.lineStyle(thick ? 4 : 1,borderRGB,border_a);			outline(g);		}				// TODO... move these helper functions to a common class, maybe UVSprite ?		private function makeColor(r:Number, g:Number, b:Number, a:Number):uint {			if (r > 1) r=1;			if (g > 1) g=1;			if (b > 1) b=1;			if (a > 1) a=1;			if (r < 0) r=0;			if (g < 0) g=0;			if (b < 0) b=0;			if (a < 0) a=0;			return ((Math.floor(a*255) & 0xFF) << 24) |			       ((Math.floor(r*255) & 0xFF) << 16) |			       ((Math.floor(g*255) & 0xFF) << 8) | 				   (Math.floor(b*255) & 0xFF);		}				private function unitize(n:Number):Number {			if (n < 0) n = 0;			if (n > 1) n = 1;			return n;		}				// TODO... ths should be shared code!!				private var _tMat:Matrix = new Matrix();		private var _sMat:Matrix = new Matrix();				private function hurlTriangle(p0:Pixel, p1:Pixel, p2:Pixel):void {			// 			// Hurl triangle bits onto the zBuffer			//			var w2:Number = _w2;			var h2:Number = _h2;			var x0:Number = p0.x0;			var y0:Number = p0.y0;			var x1:Number = p1.x0;			var y1:Number = p1.y0;			var x2:Number = p2.x0;			var y2:Number = p2.y0;			var u0:Number = p0.u * _wt; 			var v0:Number = p0.v * _ht; 			var u1:Number = p1.u * _wt; 			var v1:Number = p1.v * _ht;			var u2:Number = p2.u * _wt;			var v2:Number = p2.v * _ht;			var iw:Number = 1/_w;			var ih:Number = 1/(_h*_aspect); // cache me			var g:Graphics = this.graphics;			var show:Boolean = false;						if ((v0 == v1) && (v1 == v2)) show=true;			if ((u0 == u1) && (u1 == u2)) show=true;						if (show)			trace("Triangle " + // (" + i0 + "," + i1 + "," + i2 + ")" + 				  " = " + "(x0=" + x0 + ",y0=" + y0 + ") " +				  "(u0=" + u0 + ",v0=" + v0 + ")\n " +				  "(x1=" + x1 + ",y1=" + y1 + ") " +				  "(u1=" + u1 + ",v1=" + v1 + ")\n " +				  "(x2=" + x2 + ",y2=" + y2 + ") " +				  "(u2=" + u2 + ",v2=" + v2 + ") ");			// first, map from the proper location on the texture			// to the screen... without scaling the screen			_tMat.a = (u1 - u0) * iw;			_tMat.b = (v1 - v0) * iw;			_tMat.c = (u2 - u0) * ih;			_tMat.d = (v2 - v0) * ih;			_tMat.tx = u0; //u0; // Math.floor(u0)% _w;			_tMat.ty = v0; // Math.floor(v0)% _h;			_tMat.invert();			// now, scale the screen			_sMat.a = (x1 - x0) * iw;			_sMat.b = (y1 - y0) * iw;			_sMat.c = (x2 - x0) * ih;			_sMat.d = (y2 - y0) * ih;			_sMat.tx = x0;			_sMat.ty = y0;			// concatenate these two transformations into one			// first, texture to screen, then screen to scale & location			_tMat.concat(_sMat);			// draw the triangle and fill with the scaled, translated bitmap			g.moveTo(x0,y0);			g.beginBitmapFill(_raw,_tMat,true,true); // to smooth or not to smooth..			g.lineTo(x1,y1);			g.lineTo(x2,y2);			g.lineTo(x0,y0);			g.endFill();		}			}}