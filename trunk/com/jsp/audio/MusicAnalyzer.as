 /*       *      Copyright 2009 (c) Scott Penberthy, scottpenberthy.com. All Rights Reserved. *       *      This software is distributed under commercial and open source licenses. *      You may use the GPL open source license described below or you may acquire  *      a commercial license from scottpenberthy.com. You agree to be fully bound  *      by the terms of either license. Consult the LICENSE.TXT distributed with  *      this software for full details. *       *      This software is open source; you can redistribute it and/or modify it  *      under the terms of the GNU General Public License as published by the  *      Free Software Foundation; either version 2 of the License, or (at your  *      option) any later version. See the GNU General Public License for more  *      details at: http://scottpenberthy.com/legal/gplLicense.html *       *      This program is distributed WITHOUT ANY WARRANTY; without even the  *      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *       *      This GPL license does NOT permit incorporating this software into  *      proprietary programs. If you are unable to comply with the GPL, you must *      acquire a commercial license to use this software. Commercial licenses  *      for this software and support services are available by contacting *      scott.penberthy@gmail.com. * */package com.jsp.audio{	import flash.media.SoundMixer;	import flash.utils.ByteArray;	import flash.utils.getTimer;	import flash.system.Security;		public class MusicAnalyzer	{		// TODO generalize this analyzer so that it divides the spectrum into 		// a fixed set of sub-bands, using arrays.  Right now we use 3 sub-bands		// of bass, mid-range and treble and have a large collection of variables.				public static const NUM_SAMPLES:Number = 256;		public var spectrumLeft:Array = new Array(256);		public var spectrumRight:Array = new Array(256);		public var L:Array;		public var L0:Array;  							// previous wave		public var R:Array;		public var R0:Array; 							// previous wave		public var beat:Boolean = false;				// whether a beat is occurring on this frame		public var bpm:Number=0;						// beats per minute		public var wave_scale:Number = 1.0;		public var wave_smooth:Number = 1.0;				public var _t:Number;							// elapsed playing time, in seconds		public var _t0:Number;							// start time, from getTimer()				// Instant sound levels, raw		private var _bass:Number;		private var _mid:Number;		private var _treb:Number;				// Instant relative sound levels, where 1.0 = "average" for the last second				public var bass_att:Number;						// super-attenuated bass leve		public var mid_att:Number;						// super-attenuated mid-range level		public var treb_att:Number						// super-attenuated treble level		public var bass:Number;							// bass level		public var mid:Number;							// mid-range level		public var treble:Number;						// treble level		public var amp:Number;							// sound amplitude				public var bassEnergy:Number;		public var midEnergy:Number;		public var trebleEnergy:Number;				// Running averages for the last second in the bass, mid-range and treble 		// spectrum				private var _avgBass:Number=0;					// running average of raw sound energy		private var _avgMid:Number = 0; 		private var _avgTreble:Number = 0;				private var _bassLongAvg:Number=0;				// running average of average sound energy		private var _midLongAvg:Number=0;		private var _trebleLongAvg:Number=0;				// last beat times				private var _bassBeat:Number;		private var _midBeat:Number;		private var _trebleBeat:Number;		private var _beat:Number;				// in a frequency spectrum, each of the 256 samples corresponds		// to about 86hz.  Bass is 0-774Hz (9), mid-range is from		// 760Hz to 2838Hz, treble is 2838Hz-20k Hz		//		private const NUM_WAVES:Number = 1;		private const BASS_BAND:Number = 42; //9; // the first 9 frequencies, was 42		private const MID_BAND:Number = 84; // 34; // from 9th to 34thfrequencies, was 84				public function MusicAnalyzer()		{			Security.allowDomain('*');			init();		}				private function init():void {			L = new Array(NUM_SAMPLES);			R = new Array(NUM_SAMPLES);			L0 = new Array(NUM_SAMPLES);			R0 = new Array(NUM_SAMPLES);			_bassHistory = new Array(43);			_midHistory = new Array(43);			_trebleHistory = new Array(43);			reset();		}				private function clear():void {			for (var i:int=0; i < NUM_SAMPLES; i++) {				L[i] = R[i] = L0[i] = R0[i] = 0;				if (i < 43) {					_bassHistory[i] = 0;					_midHistory[i] = 0;					_trebleHistory[i] = 0;				}			}		}				public function reset():void {			_t0 = getTimer();						_bassBeat = _midBeat = _trebleBeat = _beat = _t0;						_midLongAvg = _trebleLongAvg = _bassLongAvg = 1.0;			_avgBass = _avgMid = _avgTreble = 1.0;			bass = mid = treble = amp = 1.0;			bass_att = mid_att = treb_att = 1.0;			_samples = 0;			clear();		}				private var _bassHistory:Array;		private var _midHistory:Array;		private var _trebleHistory:Array;				public function sample():void {			_t = (getTimer()-_t0)*0.001;			try {				sampleSound(wave_scale,wave_smooth);			}			catch (e:Error) {				zeroLevels();			}			computeLevels();			//detectBeat();		}				private function zeroLevels():void {			for (var i:uint=0; i<256; i++) {				L[i] = R[i] = 0;			}		}				private function sampleSound(scale:Number = 1.0, smooth:Number = 0.0):void {			// Sample the soundwave and fill our Left and Right channel			// at the same time, compute bass, mid, treble amplitude			var spec:ByteArray = new ByteArray();			var mix:Number;			SoundMixer.computeSpectrum(spec);			if (scale < 0.2) scale = 0.2;			for (var i:int=0; i<256; i++) {				L0[i] = L[i];				L[i] = scale*spec.readFloat();			}			for (i=0; i<256; i++) {				R0[i] = R[i];				R[i] = scale*spec.readFloat();			}			if (smooth > 0) {				mix = (1-smooth); 				for (i=0; i<256; i++) {					R[i] = smooth*R0[i] + mix*R[i];					L[i] = smooth*L0[i] + mix*L[i];				}			}			//R[0] = L[0];  //???		}				private function computeLevels():void {			// compute the bass, mid(dle), treble, and amp(litude) of the current sound sample			// these will be used to assist in visualization			sampleSpectrum();			computeEnergyLevels();			updateRunningAverages();			normalizeInstantEnergy();		}				private function avgMix(now:Number, avg:Number):Number {			if (now > avg) {				return avg*0.2 + now*0.8;			}			else {				return (avg+now)*0.5;			}		}				private function relMix(now:Number, avg:Number):Number {			if (Math.abs(avg) < 0.001) {				return 1.0;			}			else {				return now/avg;			}		}				private function energy(i:Number):Number {			return spectrumLeft[i]*spectrumLeft[i] + spectrumRight[i]*spectrumRight[i];		}				private function sampleSpectrum():void {			// sample the entire spectrum, in both channels			var spec:ByteArray = new ByteArray();			try {				SoundMixer.computeSpectrum(spec,true);				for (var j:uint=0; j < 256; j++) {					spectrumLeft[j] = spec.readFloat();				}				for (j=0; j < 256; j++) {					spectrumRight[j] = spec.readFloat();				}			}			catch (e:Error) {				for (var k:uint=0; k < 256; k++) {					spectrumLeft[k] = spectrumRight[k] = 0;				}			}		}				private function computeEnergyLevels():void {			//    			// Compute the sound "energy" in each of three spectral bands			//			_bass = _mid = _treb = 0;			for (var i:uint=0; i < BASS_BAND; i++) { 				_bass += energy(i);			}			for (i=BASS_BAND; i < MID_BAND; i++) {			    _mid += energy(i);			}			for (i=MID_BAND; i < 128; i++) { 				_treb += energy(i);			}			updateEnergyBuffer();		}				private function updateEnergyBuffer():void {			if (_samples > 43) {				_bassHistory.pop();				_midHistory.pop();				_trebleHistory.pop();			}			else {				_samples++;			}			_bassHistory.unshift(_bass);			_trebleHistory.unshift(_treb);			_midHistory.unshift(_mid);		}				private function updateRunningAverages():void {			var k1:Number, k2:Number;				// blending coefficients						k1 = (_t < 1) ? 0.9 : 0.992;			k2 = 1.0-k1;			_bassLongAvg = _bassLongAvg*k1 + _bass*k2;			_midLongAvg = _midLongAvg*k1 + _mid*k2;			_trebleLongAvg = _trebleLongAvg*k1 + _treb*k2;						// roll the last bass, mid and treble levels into the running average			// for sound energy (*_att)			_avgBass = avgMix(_bass,_avgBass);			_avgMid = avgMix(_mid,_avgMid);			_avgTreble = avgMix(_treb,_avgTreble);						// roll the current sound energy average into another			// running average. this gives us a sense for			// how much sound energy occurred in recent history.			bass_att = relMix(_avgBass, _bassLongAvg); 			mid_att = relMix(_avgMid, _midLongAvg); 			treb_att = relMix(_avgTreble, _trebleLongAvg);		}				private function normalizeInstantEnergy():void {			// record the instant, relative sound energy			bass = relMix(_bass, _bassLongAvg); 			mid = relMix(_mid, _midLongAvg); 			treble = relMix(_treb, _trebleLongAvg);			amp = (bass + mid + treble) * 0.3333;		}				//		// Beat detection.  See http://bit.ly/14wjG		//				private static const BEAT_FACTOR:Number = 0.92;		private static const BASS_FACTOR:Number = 1.6;		private static const MID_FACTOR:Number  = 2.2; //2.0;//99;		private static const TREBLE_FACTOR:Number = 2.5; //5;				private var _samples:Number = 0;				private function energyAverage(energies:Array):Number {			var total:Number = 0;			var len:Number = Math.min(_samples, 43);			for (var i:int=0; i < len; i++) total += energies[i];			return total/len;		}				private function detectBeat():void {			var bb:Number, mb:Number, tb:Number;			var bpm_guess:Number;						bb = mb = tb = 0;							// beat per minute, by band			bpm_guess = bpm;			bassEnergy = energyAverage(_bassHistory);			midEnergy = energyAverage(_midHistory);			trebleEnergy = energyAverage(_trebleHistory);						if (_bass > BASS_FACTOR * bassEnergy) { 				bb = 60/(_t - _bassBeat);				_bassBeat = _t;				bpm_guess = BEAT_FACTOR*bpm_guess + (1-BEAT_FACTOR)*bb;			}			if (_mid > MID_FACTOR * midEnergy) {				mb = 60/(_t - _midBeat);				_midBeat = _t;				bpm_guess = BEAT_FACTOR*bpm_guess + (1-BEAT_FACTOR)*mb;			}			if (_treb > TREBLE_FACTOR * trebleEnergy) {				tb = 60/(_t - _trebleBeat);				_trebleBeat = _t;				bpm_guess = BEAT_FACTOR*bpm_guess + (1-BEAT_FACTOR)*tb;			}			bpm = BEAT_FACTOR*bpm + (1-BEAT_FACTOR)*bpm_guess;			beat = !((bb == 0) && (mb == 0) && (tb == 0));						if (false) {				trace("Beat!  Beats per minute = "+Math.round(bpm));				trace("bass = "+(bb != 0)+" now="+_bass+" avg="+_bassLongAvg);				trace("mid = "+(mb != 0)+" now="+_mid+" avg="+_midLongAvg);				trace("treble = "+(tb != 0)+ " now="+_treb+" avg="+_trebleLongAvg);			}		}	}}