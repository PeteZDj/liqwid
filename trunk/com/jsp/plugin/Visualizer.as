/*       *      Copyright 2009 (c) Scott Penberthy, scottpenberthy.com. All Rights Reserved. *       *      This software is distributed under commercial and open source licenses. *      You may use the GPL open source license described below or you may acquire  *      a commercial license from scottpenberthy.com. You agree to be fully bound  *      by the terms of either license. Consult the LICENSE.TXT distributed with  *      this software for full details. *       *      This software is open source; you can redistribute it and/or modify it  *      under the terms of the GNU General Public License as published by the  *      Free Software Foundation; either version 2 of the License, or (at your  *      option) any later version. See the GNU General Public License for more  *      details at: http://scottpenberthy.com/legal/gplLicense.html *       *      This program is distributed WITHOUT ANY WARRANTY; without even the  *      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *       *      This GPL license does NOT permit incorporating this software into  *      proprietary programs. If you are unable to comply with the GPL, you must *      acquire a commercial license to use this software. Commercial licenses  *      for this software and support services are available by contacting *      scott.penberthy@gmail.com. * */package com.jsp.plugin { 	import flash.display.BitmapData;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.utils.Timer;	import flash.utils.getTimer;	import com.jsp.audio.MusicAnalyzer;	import com.jsp.audio.Wave;	import com.jsp.calculator.*;	import com.jsp.graphics.Border;	import com.jsp.graphics.Frame;	import com.jsp.graphics.uvPolygon;	import com.jsp.graphics.uvSprite;	import com.jsp.graphics.Shader;   	import com.jsp.graphics.SlideShow;	import com.jsp.video.Webcam;	import com.jsp.feeds.PresetFeed;	import com.jsp.events.LiqwidEvent;	import com.jsp.events.JavaScriptAPI;	import com.jsp.events.JSEvent;		public class Visualizer extends uvSprite {		protected var _wave:Wave;						// current wave form	protected var _frame:Frame;						// basic frame	protected var _border:Border;					// frame's border	protected var _cam:Webcam;						// a webcam, if available	protected var _show:SlideShow;					// a slideshow of pictures	protected var _shader:Shader;					// the pixel shader	protected var _time:Number;							protected var _t:Number;						// current time	protected var _ma:MusicAnalyzer;				// something to analyze waveforms	protected var _timer:Timer;					protected var _lastShapeTime:Number = 0;	protected var _shaderTime:Number=0;	protected var _presetFeed:PresetFeed;	protected var _presetRepeat:Boolean = false;		// true when we keep repeating the current preset	protected var _program:Object = null;				// current program has author, title, preset attributes	protected var _api:JavaScriptAPI;		protected static var _programs:Array = 	[{author: "Scott Penberthy",	  title: "Loudness zoomer",	  preset: "zoom=min(0.9*zoom+0.1*amp,6)*(1+sin(time*3.14)*0.25); zoom_exp=min(2,0.9*zoom_exp + 0.1*amp); dx = 0.5*(sin(time*3.1415/4)+1);"},	  {author: "Scott Penberthy",	   title: "Ethereal image tunnel",	   preset: "per_pixel_1=zoom=if(above(amp,1),1+rad*rad,1-0.5*rad);cx=treble;cy=treble;zoom_exp=(0.9*zoom_exp+0.1*amp);warp=if(above(bass,1),2*bass,0);warp_speed=amp"},	  {author: "Scott Penberthy",	   title: "Checkerboard dance",	   preset: "xx=if(above(rand(1),0.5),treble,bass);cx=0.9*cx+0.1*xx;cy=cy*0.9+0.1*(0.5+0.5*amp);dx=dx*0.98+0.02*amp*sin(time);dy=dy*0.98+0.02*amp*cos(time)"}	   ];	       /** This function is automatically called by the player after the plugin has loaded. **/    public function Visualizer(width:Number, height:Number):void {		super(width,height);		init();	}		private function init():void {		var t:Token = new Token();		var m:Milk = new Milk();		_api = null;		createElements();	}		public function useAPI(api:JavaScriptAPI):void {		_api = api;		_api.addEventListener(JSEvent.JS_EVENT, jsEventHandler);	}		private function jsEventHandler(e:JSEvent):void {		doCommand(e.data.type, e.data.data);	}		protected function doCommand(type:String, data:*):void {		switch (type) {			case 'SET_PARM':				if (_api) _api.sendEvent('ECHO','set '+data.parm+' to '+data.value);				break;			default:				if (_api) _api.sendEvent('ECHO', "type="+type+" data="+data);				break;		}	}				// module 8		private function createElements():void {		_ma = new MusicAnalyzer();		_timer = new Timer(50);		_time = getTimer();		_t = 0;		_timer.addEventListener(TimerEvent.TIMER, musicTic);		_frame = new Frame(_w,_h);		_wave = _frame.wave;		_border = _frame.border;		_show = null;		_shader = new Shader(8,10,_w,_h);		_program = null; //_programs[Math.floor(Math.random()*_programs.length)];		_frame.useShader(_shader);		addChild(_frame);		//updatePreset();	}	protected function pickShader():void {		// not quite right		var len:int = _programs.length;		if (_presetRepeat && _program.preset) return;				if (len > 0) {			var i:int = Math.floor(Math.random()*len);			var spec:Object = _programs[i];			_program = spec;			resetTime();			updatePreset();			trace("Now showing '"+spec.title+"' by "+spec.author);			trace(_program.preset);		}		if (_presetFeed) {			_presetFeed.randomPreset();		}	}		public function lockPreset():void {		_presetRepeat = true;	}		public function unlockPreset():void {		_presetRepeat = false;	}		public function forcePreset(preset:String, author:String='No author', title:String='Untitled'):void {		lockPreset();		_program.preset = preset;		_program.author = author;		_program.title = title;		updatePreset();	}		protected function updatePreset():void {		if (_program && _program.preset) {			_shader.storeProgram(_program.preset);			if (_api) _api.sendEvent('PRESET',_program);		}	}		protected function resetTime():void {		_time = getTimer();		_shaderTime = _time;		_t = 0;	}			public function usePresetFeed(pf:PresetFeed):void {		if (_presetFeed) {			_presetFeed.removeEventListener(LiqwidEvent.PRESET, newPreset);		}		_presetFeed = pf;		_presetFeed.addEventListener(LiqwidEvent.PRESET, newPreset);	}		private function newPreset(e:LiqwidEvent):void {		var preset:Object = e.data;		if (preset.author) {			// update a lower third or title or something here			//trace("Loaded preset '"+preset.title+"', by "+preset.author);		}		_programs.push(preset);		if (_program == null || _program.preset == null) pickShader();	}		public function usePictures(pics:Array, speed:int = 3):void {		if (_show) {			_show.stop();			// we need a _show.dispose(); to clean up memory, i think			_show = null;		}		_show = new SlideShow(pics,speed);	}		public function useCamera():void {		if (_cam) return;		_cam = new Webcam();		_cam.startCamera();	}		public function play():void {		//trace("** Starting visualizer");		resetTime();		_timer.start();		//if (_show) _show.start();	}		public function pause():void {		//trace("** Stopping visualizer");		resetTime();		if (_show) _show.stop();		_timer.stop();	}		protected var _progress:Number; 		// progress through this preset, 0-1		private function musicTic(t:TimerEvent):void {		//trace("Viz tic");		_t = 0.001*(getTimer()-_time);		_ma.sample();		_progress = ((getTimer() - _shaderTime)*0.001)/10;		if (_progress > 1  || _program == null) {			_program = {};			pickShader();		}		tic();	}		protected function tic():void {		updateShader();		updateWave();	}		protected function updateShader():void {		_shader.store('bass',_ma.bass);		_shader.store('mid',_ma.mid);		_shader.store('treble',_ma.treble);		_shader.store('amp',_ma.amp);		_shader.store('time',_t);		_shader.motionVectors(4,4,_ma.treble/6,_ma.mid/6,_ma.bass/2,_ma.amp/6);		_shader.mv_l = _ma.amp/4;		//_shader.updatePixels();	}		protected function mypreset(o:String):String {		var ans:String = '';		var preset:String = o+"\n";				ans += "sint = sin(time); cost = cos(time);";		ans += "wave_x = 0.5 + 0.1*sint;";		ans += "wave_y = 0.5 + 0.1*cost;";		ans += "monitor = time;";		ans += "wave_r = bass/2;";		ans += "wave_g = mid/2;";		ans += "wave_b = treble/2;";		ans += "wave_a = amp/2;";		ans += "wave_mode = 7;";		ans += "wave_mystery = 0.2*sint;";		ans += "wave_blur = 0.2;";		ans += "wave_thick = 1;";		ans += "ob_r = (sint+1)*0.5;";		ans += "ob_g = bass/(4*sint);";		ans += "ob_b = bass/4;";		ans += "ob_a = mid;";		ans += "ob_size = 0.02;";		ans += "ib_r = amp/4;";		ans += "ib_g = amp/4;";		ans += "ib_b = (cost+1)*0.5;";		ans += "ib_a = mid;";		ans += "ib_size = 0.02;";		ans += "ztarget = max(0.2,bass/amp);";		ans += "zz = zz*0.92 + ztarget*0.08;";		ans += "zoom = zz;"				preset = 'per_frame_0='+o+"\n";		var s:Array = ans.split(';');		for (var i:int=0; i < s.length-1; i++) {			if (s[i].length) preset += "per_frame_"+(i+1)+"="+s[i]+";\n";		}				// Shape init codes				ans = 'zz = zoom;';		s = ans.split(';');		for (i=0; i < s.length-1; i++) {			if (s[i].length) preset += "per_frame_init"+(i+1)+"="+s[i]+";\n";		}				// Shape codes				ans = 'enabled=1; sides = rand(12);';		ans += 'r = rand(12)/12; g=rand(12)/12; b=rand(12)/12; a=rand(12)/12;'		ans += 'r2 = rand(12)/12; g2=rand(12)/12; b2=rand(12)/12; a2=rand(12)/12;';		ans += 'border_r = rand(12)/12; border_g = rand(12)/12; border_b = rand(12)/12; border_a = rand(12)/12;';		ans += 'x = rand(24)/24; y=rand(24)/24; rad=0.4;';		ans += 've_orient = rand(4); ve_alpha = 0.1;';		s = ans.split(';');		for (i=0; i < s.length - 1; i++) {			if (s[i].length) preset += 'shapecode_0_'+i+'=' + s[i] + ";\n";		}				// Shape per frame		ans = 'tex_zoom = tex_zoom * 0.9 + 0.1*(0.2+0.8*bass);';		ans += 'rad = rad*0.9 + 0.1*(0.1+0.4*amp);';		ans += 'd = sin(time)*0.5;';		ans += 'xx = 0.98*xx + 0.02*d;';		ans += 'yy = 0.98*yy + 0.02*d;';		ans += 'x=xx;';		ans += 'y=yy;';				s = ans.split(';');		for (i=0; i < s.length - 1; i++) {			if (s[i].length) preset += 'shape_0_per_frame'+i+'='+s[i]+";\n";		}				// Shape init		ans = 'xx = rand(32)/32; yy=rand(32)/32; rad=0.4; tex_zoom=1.0; textured=rand(3);';		s = ans.split(';');		for (i=0; i < s.length - 1; i++) {			if (s[i].length) preset += 'shape_0_per_frame_init'+i+'='+s[i]+";\n";		}		trace("New preset!\n"+preset);		return preset;	}		protected function updateWave():void {		var sint:Number = Math.sin(_t);		var cost:Number = Math.cos(_t);		//_wave.dots = true;		//_wave.scale = 1.2;		_wave.uv(0.5+0.1*sint, 0.5+0.1*cost); //0.5,0.0);		_wave.setColor(_ma.bass/2, _ma.mid/2, _ma.treble/2, _ma.amp/2);		//_wave.setGlow(0.2+_ma.bass/4, _ma.bass, 1, 1, _ma.amp/2);		_wave.setLevels(_ma.bass, _ma.mid, _ma.treble);		_wave.sample(_ma.L, _ma.R, Wave.MILKDROP_7);		_wave.progress = _t;		_wave.mystery = 0.2*sint;		_wave.blur = 0.2;		_wave.thick = 1;		//_wave.glow = 0.1;		_border.outer((sint+1)*0.5,_ma.bass/4*sint,_ma.bass/4,_ma.mid,0.02);		_border.inner(_ma.amp/4,_ma.amp/4,(cost+1)*0.5,_ma.mid,0.02);		_frame.decay = 0.98;		var zTarget:Number = Math.max(0.2,_ma.bass/_ma.amp);		var zOld:Number = _frame.echoZoom;		_frame.echoZoom = zOld*0.92+zTarget*0.08;		randomShape(_frame.shape(0));		_frame.border.blur = 0; //Math.max(0,_ma.bass/4-0.25);		_frame.echo = true;		_frame.render();	}		protected function randomShape(shape:uvPolygon):void {		var d:Number = Math.sin(_t)*0.5;		if ((_t - _lastShapeTime) >  2) {			_lastShapeTime = _t;			shape.sides = Math.random()*12;			shape.inner(Math.random(),Math.random(),Math.random(),Math.random());			shape.outer(Math.random(),Math.random(),Math.random(),Math.random());			shape.border(Math.random(),Math.random(),Math.random(),Math.random());			shape.uv(Math.random(),Math.random());			_frame.echoOrient = Math.floor(Math.random()*4);			_frame.echoAlpha = 0.1;		}		if (_show && _show.raw) shape.useTexture(_show.raw);		else if (_cam) shape.useTexture(_cam.raw);		shape.progress = _t;		shape.tex_zoom = shape.tex_zoom*0.9 + 0.1*(0.2+0.8*_ma.bass);		shape.rad = shape.rad*0.9 + 0.1*(0.1+0.4*_ma.amp);		shape.u0 = shape.u0*0.98 + 0.02*d;		shape.v0 = shape.v0*0.98 + 0.02*d;				//shape.uv(0.5,0.35);		shape.active = true;	}		override protected function afterResize():void {		//trace("Config size is "+_view.config['width']+"x"+_view.config['height']);		if (stage && stage.displayState == 'fullScreen') {			_frame.onStageResize();            _frame.x = _frame.y = 0;            _shader.resize(stage.stageWidth, stage.stageHeight);            _shader.setTextureSize(stage.stageWidth, stage.stageHeight);        }        else {           _shader.resize(_w,_h);           _shader.setTextureSize(_w,_h);           _frame.x = _frame.y = 0;		   _frame.resize(_w,_h);        }	}		}}