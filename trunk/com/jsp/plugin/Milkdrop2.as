/*       *      Copyright 2009 (c) Scott Penberthy, scottpenberthy.com. All Rights Reserved. *       *      This software is distributed under commercial and open source licenses. *      You may use the GPL open source license described below or you may acquire  *      a commercial license from scottpenberthy.com. You agree to be fully bound  *      by the terms of either license. Consult the LICENSE.TXT distributed with  *      this software for full details. *       *      This software is open source; you can redistribute it and/or modify it  *      under the terms of the GNU General Public License as published by the  *      Free Software Foundation; either version 2 of the License, or (at your  *      option) any later version. See the GNU General Public License for more  *      details at: http://scottpenberthy.com/legal/gplLicense.html *       *      This program is distributed WITHOUT ANY WARRANTY; without even the  *      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *       *      This GPL license does NOT permit incorporating this software into  *      proprietary programs. If you are unable to comply with the GPL, you must *      acquire a commercial license to use this software. Commercial licenses  *      for this software and support services are available by contacting *      scott.penberthy@gmail.com. * */package com.jsp.plugin { 	import flash.display.BitmapData;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.utils.Timer;	import flash.utils.getTimer;	import com.jsp.audio.MusicAnalyzer;	import com.jsp.audio.Wave;	import com.jsp.calculator.*;	import com.jsp.graphics.Border;	import com.jsp.graphics.Frame;	import com.jsp.graphics.uvPolygon;	import com.jsp.graphics.uvSprite;	import com.jsp.graphics.Shader;   	import com.jsp.graphics.SlideShow;	import com.jsp.video.Webcam;	import com.jsp.feeds.PresetFeed;	import com.jsp.events.LiqwidEvent;		protected var _frameConfig:Object = {		warp: 1.0,		warp_speed: 1.0,		warp_scale: 1.0,		zoom: 1.0,		rot: 0.0,		cx: 0.5,		cy: 0.5,		dx: 0.0,		dy: 0.0,		sx: 0.0,		sy: 0.0,		decay: 0.92,		scale: 1.0,		monitor: undefined,		time: 0.0,		frame: 0.0,		mouse_x: 0.5,		mouse_y: 0.5,		fps: 24,		rating: 1.0,		progress: 0.5	};		private var _exp:Expression;		override public function updatePreset():void {		//		// _program will have {author:, title:, preset:} attributes		//		_exp = new Expression(_program.preset);		_exp.compile();				// _exp now has 		//		// 1) global variables in the top-level expression		// 2) per_frame_ bytecodes to run each frame		// 3) per_pixel_ bytecodes to run each pixel		// ...				// Initialize and load up our frame				_cFrame.clear();		// TODO load defaults here		_cFrame.bytecodes = _exp.bytecodes;				// global vars		_cFrame.eval();		_cFrame.bytecodes = _exp.blockCodes(Milk.frame.init);  // init routine		_cFrame.eval();		_cFrame.bytecodes = _exp.blockCodes(Milk.frame.codes);  // first block		_cFrame.eval();				// Initialize and load up our pixel shader		writeFrame();				//STOPPED HERE				// first, parse the top-level frame attributes		_cFrame.clear();		_cFrame.load(_program.preset);		_cFrame.eval();				// now store the various bytecodes where they belong			}				private function readFrame():void {		var m:Array = _cFrame.memory;				m[Milk.FPS] = 15;		m[Milk.TIME] = _t;		m[Milk.MOUSE_X] = (mouseX - _w2) * _iw2;		m[Milk.MOUSE_Y] = (mouseY - _h2) * _ih2;		m[Milk.PROGRESS] = _progress;				m[Milk.BASS] = _ma.bass;		m[Milk.MID] = _ma.mid;		m[Milk.TREBLE] = _ma.treble;		m[Milk.BASS_ATT] = _ma.bass_att		m[Milk.MID_ATT] = _ma.mid_att;		m[Milk.TREBLE_ATT] = _ma.treble_att;		m[Milk.AMP] = _ma.amp;		_wave.progress = _t;		// TODO rename wave.progress to wave.time	}		private function writeFrame():void {		var m:Array = _cFrame.memory;			_frame.solarize = (m[Milk.SOLARIZE] > 0);		_frame.lighten = (m[Milk.LIGHTEN] > 0);		_frame.darken = (m[Milk.DARKEN] > 0);		_frame.echo = (m[Milk.VE_ALPHA] > 0);		_frame.decay = m[Milk.DECAY];				_border.ib_r = m[Milk.IB_R];		_border.ib_g = m[Milk.IB_G];		_border.ib_b = m[Milk.IB_B];		_border.ib_a = m[Milk.IB_A];		_border.ib_size = m[Milk.IB_SIZE];				_border.ob_r = m[Milk.OB_R];		_border.ob_g = m[Milk.OB_G];		_border.ob_b = m[Milk.OB_B];		_border.ob_a = m[Milk.OB_A];		_border.ob_size = m[Milk.OB_SIZE];			_wave.mode = m[Milk.WAVE_MODE];		_wave.uv(m[Milk.WAVE_X], m[Milk.WAVE_Y]);		_wave.setLevels(m[Milk.BASS], m[Milk.MID], m[Milk.TREBLE));		_wave.sample(_ma.L, _ma.R, m[Milk.WAVE_MODE]);		_wave.r = m[Milk.WAVE_R];		_wave.g = m[Milk.WAVE_G];		_wave.b = m[Milk.WAVE_B];		_wave.a = m[Milk.WAVE_A];		_wave.thick = m[Milk.WAVE_THICK];		_wave.dots = m[Milk.WAVE_DOTS];		_wave.scale = m[Milk.SCALE];		_wave.mystery = m[Milk.WAVE_PARAM];				_shader.vertexMap(copyFrameVarsToPixel);		//copyFrameVars(_shader.memory);	}		private function copyFrameVarsToPixel(p:Pixel):void {		var m:Array = _cFrame.memory;				//		// Set the zoom, center, scale, movement, and warp		// of each pixel using the values from the frame		// equations / parameters.		//				p.zoom = m[Milk.ZOOM];		p.zoom_exp = m[Milk.ZOOM_EXP];		p.cx = m[Milk.CX];		p.cy = m[Milk.CY];		p.rot = m[Milk.ROT];		p.sx = m[Milk.SX];		p.sy = m[Milk.SY];		p.dx = m[Milk.DX];		p.dy = m[Milk.DY];		p.warp = m[Milk.WARP];		p.warp_speed = m[Milk.WARP_SPEED];		p.warp_scale = m[Milk.WARP_SCALE];				// initialize the shared variables q1-q9		// which are used to pass values from one		// pixel to another				for (var to:Number=0, from:Number=Milk.Q1; to < 9; to++, from++) {			p.q[to] = m[from];		}	}			private function copyFrameVars(to:Array):void {		var from:Array = _cFrame.memory;		var start:Number = Milk.FRAME_START;		var end:Number = Milk.FRAME_END;				for (var i:uint; i <= end; i++) {			to[i] = from[i];		}	}	protected var _fxConfig:Object = {		darkcenter:	false,		darkencenter: false,		ve_zoom: 0.5,		ve_orient: 1,		ve_alpha: 0,		invert: false,		brighten: false,		darken: false,		solarize: false	};		protected var _waveConfig:Object = {		wave_dots: false,		max_color: true,		wave_param: 0.0,		wave_alpha_start: 0.0,		wave_alpha_end: 1.0,		wave_mode: 7,		wave_x: 0.5,		wave_y: 0.5,		wave_r: 0.5,		wave_g: 0.5,		wave_b: 0.5,		wave_a: 1.0,		wave_thick: false,		wave_additive: false,		wave_brighten: true,		mod_wave_alpha_by_volume: false	};	protected var _borderConfig:Object = {		ob_size: 0.02,		ob_r: 0.5,		ob_g: 0.5,		ob_b: 0.5,		ob_a: 0.0,		ib_size: 0.02,		ib_r: 0.5,		ib_g: 0.5,		ib_b: 0.5,		ib_a: 0.0	};		protected var _samplerConfig:Object = {		scale_sound: 1.0,		smooth: 0.9,		interpolate: true,		mid: 0,		bass: 0,		treble: 0,		mid_att: 0,		bas_att: 0,		treble_att: 0,		amp: 0	};		protected var _pixelConfig:Object = {		meshx: 12,		meshy: 9,		x: 0,		y: 0,		ang: 0,		rad: 0,		wrap: true,		q1: 0,		q2: 0,		q3: 0,		q4: 0,		q5: 0,		q6: 0,		q7: 0,		q8: 0	};			protected var _mvConfig:Object = {		motionVectors: false,		mv_r: 1,		mv_g: 1,		mv_b: 1,		mv_a: 0,		mv_x: 0,		mv_y: 0,		mv_dx: 0.01,		mv_dy: 0.01,		mv_l: 1	};		protected var _shapeConfig:Object = {		enabled: false,		sides: 4,		thick: 1,		additive: false,		textured: false,		tex_zoom: 1.0,		tex_ang: 0.0,		sample: 0.0, // unused ?		r: 1,		g: 1,		b: 1,		a: 0,		r2: 1,		g2: 1,		b2: 1,		a2: 0,		border_r: 1,		border_g: 1,		border_b: 1,		border_a: 0,		t1: 0,		t2: 0,		t3: 0,		t4: 0,		t5: 0,		t6: 0,		t7: 0,		t8: 0,		t9: 0	};		private var _block:Array;	private var _frameBlock:Array;		// calculators for computing preset values from equations	private var _cFrame:Calculator;	private var _cPixel:Calculator;	private var _cShapes:Array;		public class Milkdrop extends Visualizer {    /** This function is automatically called by the player after the plugin has loaded. **/    public function Milkdrop(width:Number, height:Number):void {		super(width,height);		init();	}		private function init():void {		createCalculators();		createBlocks();		initBlocks();		// we need a calculator for the frame, shape, custom wave, and pixel shader	}		private function createCalculators():void {		_cFrame = new Calculator();		_cPixel = new Calculator();		_cShapes = new Array(Frame.MAX_SHAPES);		for (var i:int=0; i < Frame.MAX_SHAPES; i++) {			_cShapes[i] = new Calculator();		}	}		private function createBlocks():void {		createFrameBlock();		createPixelBlock();		createShapeBlocks();	}	private function createFrameBlock():void {		// not quite... first collect the vars,then create a block		// by calling _b = _c.makeFunctionBlock(ARGS);		// where _c is a new Calculator();		//		var names:Array = new Array();		addNames(names, _frameConfig);		addNames(names, _fxConfig);		addNames(names, _waveConfig);		addNames(names, _borderConfig);		addNames(names, _mvConfig);		addNames(names, _samplerConfig);		_frameBlock = _cFrame.makeFunctionBlock(names);	}		private function createPixelBlock():void		var names:Array = new Array();		addNames(names, _pixelConfig);		_pixelBlock = _cFrame.makeFunctionBlock(names);	}		private function createShapeBlocks():void {		var names:Array = new Array();		addNames(names, _shapeConfig);		_shapeBlocks = new Array(Frame.MAX_SHAPES);		for (var i:int=0; i < Frame.MAX_SHAPES; i++) {			_shapeBlock[i] = _cShapes[i].makeFunctionBlock(names);		}	}		private function initBlocks():void {		initFrameBlock();		initPixelBlock();		initShapeBlocks();	}		private function initFrameBlock():void {		initVar(_frameBlock, _frameConfig);		initVar(_frameBlock, _fxConfig);		initVar(_frameBlock, _waveConfig);		initVar(_frameBlock, _borderConfig);		initVar(_frameBlock, _mvConfig);		initVar(_frameBlock, _samplerConfig);	}		private function initPixelBlock():void {		initVar(_pixelBlock, _pixelConfig);	}		private function initShapeBlocks():void {		for (var i:int=0; i < Frame.MAX_SHAPES; i++) {			initVar(_shapeBlock[i], _shapeConfig);		}	}		private function addNames(a:Array, o:Object):void {		for (var key:String in o) {			a.push(key);		}	}		private var initVar(block:Array, vals:Object):void {		for (var key:String in vals) {			block[key] = vals[key];		}	}		override protected function tic():void {		updateBlocks();		updatePic();		updateWave();	}		private function updateBlocks():void {		updateFrameBlock();	}		protected function updatePic():void {				_shader.store('bass',_ma.bass);		_shader.store('treb',_ma.treble);		_shader.store('amp',_ma.treble);		_shader.store('time',_t);		_shader.motionVectors(4,4,_ma.treble/6,_ma.mid/6,_ma.bass/2,_ma.amp/6);		_shader.mv_l = _ma.amp/4;		if (_frame.raw) {			_shader.run(_t);			_shader.drawMotionVectors(_frame.buffer);			_shader.textureMap(_frame.buffer, _frame.raw);		}	}		protected function updateWave():void {		var sint:Number = Math.sin(_t);		var cost:Number = Math.cos(_t);		//_wave.dots = true;		//_wave.scale = 1.2;		_wave.uv(0.5+0.1*sint, 0.5+0.1*cost); //0.5,0.0);		_wave.setColor(_ma.bass/2, _ma.mid/2, _ma.treble/2, _ma.amp/2);		//_wave.setGlow(0.2+_ma.bass/4, _ma.bass, 1, 1, _ma.amp/2);		_wave.setLevels(_ma.bass, _ma.mid, _ma.treble);		_wave.sample(_ma.L, _ma.R, Wave.MILKDROP_7);		_wave.progress = _t;		_wave.mystery = 0.2*sint;		_wave.blur = 0.2;		_wave.thick = 1;		//_wave.glow = 0.1;		_border.outer((sint+1)*0.5,_ma.bass/4*sint,_ma.bass/4,_ma.mid,0.02);		_border.inner(_ma.amp/4,_ma.amp/4,(cost+1)*0.5,_ma.mid,0.02);		_frame.decay = 0.98;		var zTarget:Number = Math.max(0.4,_ma.bass/_ma.amp);		var zOld:Number = _frame.echoZoom;		_frame.echoZoom = zOld*0.92+zTarget*0.08;		randomShape(_frame.shape(0));		_frame.border.blur = 0; //Math.max(0,_ma.bass/4-0.25);		_frame.echo = true;		_frame.render();	}		protected function randomShape(shape:uvPolygon):void {		var d:Number = Math.sin(_t)*0.5;		if ((_t - _lastShapeTime) >  2) {			_lastShapeTime = _t;			shape.sides = Math.random()*12;			shape.inner(Math.random(),Math.random(),Math.random(),Math.random());			shape.outer(Math.random(),Math.random(),Math.random(),Math.random());			shape.border(Math.random(),Math.random(),Math.random(),Math.random());			shape.uv(Math.random(),Math.random());			_frame.echoOrient = Math.floor(Math.random()*4);			_frame.echoAlpha = 0.1;		}		if (_show && _show.raw) shape.useTexture(_show.raw);		else if (_cam) shape.useTexture(_cam.raw);		shape.progress = _t;		shape.tex_zoom = shape.tex_zoom*0.9 + 0.1*(0.2+0.8*_ma.bass);		shape.rad = shape.rad*0.9 + 0.1*(0.1+0.4*_ma.amp);		shape.u0 = shape.u0*0.98 + 0.02*d;		shape.v0 = shape.v0*0.98 + 0.02*d;				//shape.uv(0.5,0.35);		shape.active = true;	}		}}