/*       *      Copyright 2009 (c) Scott Penberthy, scottpenberthy.com. All Rights Reserved. *       *      This software is distributed under commercial and open source licenses. *      You may use the GPL open source license described below or you may acquire  *      a commercial license from scottpenberthy.com. You agree to be fully bound  *      by the terms of either license. Consult the LICENSE.TXT distributed with  *      this software for full details. *       *      This software is open source; you can redistribute it and/or modify it  *      under the terms of the GNU General Public License as published by the  *      Free Software Foundation; either version 2 of the License, or (at your  *      option) any later version. See the GNU General Public License for more  *      details at: http://scottpenberthy.com/legal/gplLicense.html *       *      This program is distributed WITHOUT ANY WARRANTY; without even the  *      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *       *      This GPL license does NOT permit incorporating this software into  *      proprietary programs. If you are unable to comply with the GPL, you must *      acquire a commercial license to use this software. Commercial licenses  *      for this software and support services are available by contacting *      scott.penberthy@gmail.com. * */package com.jsp.calculator{	public class VirtualMachine	{		private var _stack:Array;		private var _fmap:Array;		private var _memory:Array;				public function VirtualMachine()		{			_stack = new Array();			_fmap = new Array();			init();		}				private function init():void {			_fmap[Op.CALL1] = opCall1;			_fmap[Op.CALL2] = opCall2;			_fmap[Op.CALL3] = opCall3;			_fmap[Op.LOOKUP] = opLookup;			_fmap[Op.PUSH] = opPush;			_fmap[Op.STORE] = opStore;			}				public function eval(byteCodes:Array, memory:Array):void {			var len:Number = byteCodes.length;			var o:Op;						_memory = memory;			for (var i:uint=0; i < len; i++) {				o = byteCodes[i];				_fmap[o.code](o);				/**				if (_stack.length && isNaN(_stack[_stack.length-1])) {					_stack.pop();					_stack.push(0);					//trace("NaN! returned from "+o.toString()+" converted to zero.");				}				**/			}			_memory = null;					}				private function opCall1(o:Op):void {			var v1:Number = _stack.pop();			_stack.push(Token.t2f[o.token](v1));		}				private function opCall2(o:Op):void {			var v2:Number = _stack.pop();			var v1:Number = _stack.pop();			_stack.push(Token.t2f[o.token](v1,v2));		}				private function opCall3(o:Op):void {			var v3:Number = _stack.pop();			var v2:Number = _stack.pop();			var v1:Number = _stack.pop();			_stack.push(Token.t2f[o.token](v1,v2,v3));		}				private function opLookup(o:Op):void {			//if (o.token >= _memory.length) trace("VM: Out of bounds error at "+o.toString());			_stack.push(_memory[o.token]);		}				private function opStore(o:Op):void {			//if (o.token >= _memory.length) trace("VM: Out of bounds error at "+o.toString());			var v1:Number = _stack.pop();			if (isNaN(v1)) {				trace("VM: NaN value for "+Token.t2s[o.token]);				v1 = 0;			}			_memory[o.token] = v1;		}				private function opPush(o:Op):void {			_stack.push(o.val);		}	}}