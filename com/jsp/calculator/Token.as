/*       *      Copyright 2009 (c) Scott Penberthy, scottpenberthy.com. All Rights Reserved. *       *      This software is distributed under commercial and open source licenses. *      You may use the GPL open source license described below or you may acquire  *      a commercial license from scottpenberthy.com. You agree to be fully bound  *      by the terms of either license. Consult the LICENSE.TXT distributed with  *      this software for full details. *       *      This software is open source; you can redistribute it and/or modify it  *      under the terms of the GNU General Public License as published by the  *      Free Software Foundation; either version 2 of the License, or (at your  *      option) any later version. See the GNU General Public License for more  *      details at: http://scottpenberthy.com/legal/gplLicense.html *       *      This program is distributed WITHOUT ANY WARRANTY; without even the  *      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *       *      This GPL license does NOT permit incorporating this software into  *      proprietary programs. If you are unable to comply with the GPL, you must *      acquire a commercial license to use this software. Commercial licenses  *      for this software and support services are available by contacting *      scott.penberthy@gmail.com. * */package com.jsp.calculator {		import flash.utils.Dictionary;	public class Token {				public static const UNKNOWN:Number = -1;		private static var count:uint = 0;		private static var blocks:uint = 0;		private static var _names:Dictionary = null;				// symbol names		private static var _prefix:Dictionary = null;		public static var t2s:Array;								// map tokens to symbols		public static var t2f:Array;								// map tokens to functions		public static var t2b:Array;								// map tokens to block identifier		public static var hasMany:Array;							// true if there are many of the tokens, e.g., token_i									public static var isBool:Array;		public static var arity:Array;		public function Token() {			if (_names == null) {				_names = new Dictionary();				_prefix = new Dictionary();				t2s = new Array();				t2f = new Array();				t2b = new Array();				arity = new Array();					isBool = new Array();				hasMany = new Array();			}		}				public static function registerSymbol(name:String, boolean:Boolean = false):Number {			var id:Number = count;			if (_names.hasOwnProperty(name)) {				//trace("Warning - duplicate symbol '"+name+"'");				id = _names[name];				isBool[id] = boolean;			}			else {				_names[name] = id;				t2s[id] = name;				isBool[id] = boolean;				t2f[id] = null;				arity[id] = 0;				count++;			}			//trace("new symbol "+name+" = "+id);			return id;		}				public static function registerFunction(name:String, fn:Function, numArgs:Number):Number {			var id:Number = registerSymbol(name, false);			t2f[id] = fn;			arity[id] = numArgs;			//trace("new function "+name+" = "+id);						return id;		}				public static function registerBlock(prefix:String, multiple:Boolean = false):Number {			//			// A block of equations is identified by a prefix, as in			//			// per_pixel_			// shapecode_			// shape_			// wavecode_			// wave_			//			var id:Number = blocks;			if (_prefix.hasOwnProperty(prefix)) {				//trace("Warning - duplicate block prefix '"+prefix+"'");				id = _prefix[prefix];			}			else {				_prefix[prefix] = id;				t2b[id] = prefix;				hasMany[id] = multiple;				blocks++;			}			return id;		}				public static function blockNum(name:String, blockId:Number):Number {			var prefix:String = t2b[blockId];			var len:Number = prefix.length;			if (hasMany[blockId]) {				return Number(name.substring(len));			}			else {				return -1;			}		}				public static function blockParm(name:String, blockId:Number):String {			var prefix:String = t2b[blockId];			var len:Number = prefix.length;			if (hasMany[blockId]) {				return '';			}			else {				return name.substring(len);			}		}			public static function isBlock(name:String):Number {			//			// Return the block prefix token that matches the first part of NAME			// or -1 if there is no match.			//			var candidate:Number, clen:Number;			clen = candidate = -1;			for (var i:int=0; i < blocks; i++) {				var prefix:String = t2b[i];				if (name.indexOf(prefix) == 0) {					var thisLen:Number = prefix.length; 					if (thisLen > clen) {						clen = thisLen;						candidate = i;					}				}			}			return candidate;		}				public static function blockId(name:String):Number {			return isBlock(name);		}				public static function isBoolean(tokenId:Number):Boolean {			return isBool[tokenId];		}				public static function ize(name:String, create:Boolean = true):Number {			if (_names.hasOwnProperty(name)) {				return _names[name];			}			return create ? registerSymbol(name) : UNKNOWN;		}				public static function memorySize():Number {			return count+1;		}			}}