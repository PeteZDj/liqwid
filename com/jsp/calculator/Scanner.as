/*       *      Copyright 2009 (c) Scott Penberthy, scottpenberthy.com. All Rights Reserved. *       *      This software is distributed under commercial and open source licenses. *      You may use the GPL open source license described below or you may acquire  *      a commercial license from scottpenberthy.com. You agree to be fully bound  *      by the terms of either license. Consult the LICENSE.TXT distributed with  *      this software for full details. *       *      This software is open source; you can redistribute it and/or modify it  *      under the terms of the GNU General Public License as published by the  *      Free Software Foundation; either version 2 of the License, or (at your  *      option) any later version. See the GNU General Public License for more  *      details at: http://scottpenberthy.com/legal/gplLicense.html *       *      This program is distributed WITHOUT ANY WARRANTY; without even the  *      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *       *      This GPL license does NOT permit incorporating this software into  *      proprietary programs. If you are unable to comply with the GPL, you must *      acquire a commercial license to use this software. Commercial licenses  *      for this software and support services are available by contacting *      scott.penberthy@gmail.com. * */package com.jsp.calculator {		public class Scanner {		private const TOK_IDENT:int = 0;				private const code_symbols:Array = 		  new Array("(".charCodeAt(0), ")".charCodeAt(0), "$".charCodeAt(0), "*".charCodeAt(0), 					"+".charCodeAt(0), "-".charCodeAt(0), "%".charCodeAt(0), "&".charCodeAt(0),					"|".charCodeAt(0), ",".charCodeAt(0), "=".charCodeAt(0), "/".charCodeAt(0),					";".charCodeAt(0), "[".charCodeAt(0), "]".charCodeAt(0));															public const TOK_LPAREN:int=0;		public const TOK_RPAREN:int=1;		public const TOK_DOLLAR:int=2;		public const TOK_TIMES:int=3;		public const TOK_PLUS:int=4;		public const TOK_MINUS:int=5;		public const TOK_MOD:int=6;		public const TOK_AMP:int=7;		public const TOK_OR:int=8;		public const TOK_COMMA:int=9;		public const TOK_EQUAL:int=10;		public const TOK_DIVIDE:int=11;		public const TOK_SEMI:int=12;		public const TOK_LBRACKET:int=13;		public const TOK_RBRACKET:int=14;		public const TOK_NEWLINE:int=15;		public const TOK_DOUBLESLASH:int=16;		public const TOK_DOUBLEPLUS:int=17;		public const TOK_DOUBLEMINUS:int=18;				public const TOK_NUMBER:int = 1000;		public const TOK_IDENTIFIER:int = 2000;		public const TOK_SYMBOL:int = 3000;		public const TOK_END:int = 4000;		public const TOK_FN:int = 4001;		public const TOK_EQN:int = 400;		public const TOK_SET:int = 4002;		public const TOK_UNKNOWN:int = -1;				private const code_A:int = "A".charCodeAt(0);		private const code_Z:int = code_A + 25;		private const code_0:int = "0".charCodeAt(0);		private const code_9:int = code_0 + 9;		private const code_a:int = "a".charCodeAt(0);		private const code_z:int = code_a + 25;		private const code_uscore:int = "_".charCodeAt(0);		private const code_dot:int = ".".charCodeAt(0);		private const code_space:int = " ".charCodeAt(0);		private const code_tab:int = "\t".charCodeAt(0);		private const code_return:int = "\r".charCodeAt(0);		private const code_newline:int = "\n".charCodeAt(0);		private const code_minus:int = "-".charCodeAt(0);		private const code_semi:int = ";".charCodeAt(0);		private const S_START:int=0;		private const S_NUMBER:int=1;		private const S_IDENT:int=2;		private const S_SYMBOL:int=3;		private const S_BREAK:int=4;		private const S_END:int=5;				private var _s:String;		private var _ptr:int = 0;		private var _start:int = 0;		private var _end:int = 0;		private var _state:int = S_START;		private var _c:int = 0;		private var _lookahead:int=0;				public var token:int = TOK_UNKNOWN;				public function Scanner(input:String):void {			setString(input);		}				public function setString(input:String):void {			_s = input;			_start = 0;			_ptr = _start;			_c = _s.charCodeAt(_ptr);			_end = input.length - 1;			_lookahead = (_end > 0) ? _s.charCodeAt(_ptr+1) : -1;		}				private function isAlpha():Boolean {			// return true if the current character is  alphabetic			// it may be faster to use native string searching here			return (((_c >= code_A) && (_c <= code_Z)) ||					((_c >= code_a) && (_c <= code_z)) ||					(_c == code_uscore));		}				private function isWhiteSpace():Boolean {			// it may be faster to use native string searching here			return ((_c == code_space) || (_c == code_tab)); //  || (_c < code_space));				  //  (_c == code_return) || (_c == code_newline));		}				private function isNewline():Boolean {			return ((_c == code_return) || (_c == code_newline));		}				private function isDigit():Boolean {			// return true if the current character is a digit			return ((_c >= code_0) && (_c <= code_9));		}				public function skipWhitespace():void {		  while (isWhiteSpace() && (_ptr <= _end)) moveHead();		}				public function eol():Boolean {			return (_c == code_return) || (_c == code_newline) || (_c == code_semi);		}				public function eolNoSemi():Boolean {			return (_c == code_return) || (_c == code_newline);		}				public function getLine():Boolean {			_state = S_END;			if (_ptr > _end) {				_start = _end;				token = TOK_END;				return true;			}			_start = _ptr;			while ((_ptr <= _end) && !eolNoSemi()) moveHead();			return true;		}			  		public function getSym():Boolean {			_state = S_END;			if (isWhiteSpace()) skipWhitespace(); // c will point to first non-white, ptr the next char			if (_ptr > _end) {				_start = _end;				token = TOK_END;				return false;			}			_start = _ptr;			if (isDigit() || (_c == code_dot)) {			   _state = S_NUMBER;			}			else if (isAlpha()) {				_state = S_IDENT;			}			else if (isNewline()) {				_state = S_BREAK;			}			else {				_state = S_SYMBOL;			}			return advanceState();		}				private function advanceState():Boolean {			switch (_state) {				case S_NUMBER:  return doNumber(); break;				case S_IDENT:   return doIdent(); break;				case S_SYMBOL:  return doSymbol(); break;				case S_BREAK:   return doBreak(); break;				case S_END:     				default:		return false; break;			}		}				public function prettyToken():String {			return symValue();		}				private function checkForDoubles():void {			if (_lookahead == _c) {				switch (token) {					case TOK_PLUS:		token=TOK_DOUBLEPLUS; moveHead(); break;					case TOK_MINUS:		token=TOK_DOUBLEMINUS; moveHead(); break;					case TOK_DIVIDE:	token=TOK_DOUBLESLASH; moveHead(); break;					default:				} 			}		}				private function doSymbol():Boolean {			token = code_symbols.indexOf(_c);			checkForDoubles();			moveHead();			if (token == -1) { 			   token = TOK_UNKNOWN;			   return false;			}			return true;		}				public function backupHead():void {			_ptr--;			_c = _s.charCodeAt(_ptr);		}				public function moveHead():void {			_ptr++;			_c = _s.charCodeAt(_ptr);			if (_ptr < _end) {				_lookahead = _s.charCodeAt(_ptr+1);			}			else {				_lookahead = -1;			}		}				private function doBreak():Boolean {			token = TOK_NEWLINE;			moveHead();			return true;		}				private function doNumber():Boolean {			if (_ptr <= _end) {			  // scan numbers to the left of the decimal			  if (_c != code_dot) {				  while (isDigit() && (_ptr <= _end)) moveHead();			  }			  // scan numbers to the right of the decimal			  if (_c == code_dot) {				  moveHead();				  while (isDigit() && (_ptr <= _end)) moveHead();			  }		    }			token = TOK_NUMBER;			//_ptr -= 1;	        return true;		}				public function doIdent():Boolean {         while ((isAlpha() || isDigit()) && (_ptr <= _end))				  moveHead();	     token = TOK_IDENTIFIER;		 return true;		}				public function symValue():String {			if (_ptr > _start) {				return _s.substring(_start,_ptr);			}			else return "";		}				public function debugString():String {			// we should get smarter and know the current line "number"			var lineNum:int = 1;			var ans:String;			var i1:Number, i2:Number;			for (var i:int=0; i < _ptr; i++) {				if (_s.charCodeAt(i) == code_newline) lineNum++;			}			ans = "Near line "+lineNum+": \n";			i1 = Math.max(0,_ptr - 40);			i2 = Math.min(i+81, _s.length);			ans += _s.substring(i1,_ptr);			ans += "[^ bug found here]";			ans += _s.substring(_ptr,i2);			return ans;		}			}}