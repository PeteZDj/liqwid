/*       *      Copyright 2009 (c) Scott Penberthy, scottpenberthy.com. All Rights Reserved. *       *      This software is distributed under commercial and open source licenses. *      You may use the GPL open source license described below or you may acquire  *      a commercial license from scottpenberthy.com. You agree to be fully bound  *      by the terms of either license. Consult the LICENSE.TXT distributed with  *      this software for full details. *       *      This software is open source; you can redistribute it and/or modify it  *      under the terms of the GNU General Public License as published by the  *      Free Software Foundation; either version 2 of the License, or (at your  *      option) any later version. See the GNU General Public License for more  *      details at: http://scottpenberthy.com/legal/gplLicense.html *       *      This program is distributed WITHOUT ANY WARRANTY; without even the  *      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *       *      This GPL license does NOT permit incorporating this software into  *      proprietary programs. If you are unable to comply with the GPL, you must *      acquire a commercial license to use this software. Commercial licenses  *      for this software and support services are available by contacting *      scott.penberthy@gmail.com. * */package com.jsp.graphics{	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.Graphics;	import flash.geom.ColorTransform;		public class VideoEcho extends uvSprite	{		public static const FLIP_VERTICAL:uint = 3;		public static const FLIP_HORIZONTAL:uint = 0;		public static const NORMAL:uint = 1;				public var orient:Number = NORMAL;		public var scale:Number = 1.0;				private var _mesh:Array;		private var _zoom:Number = 1.0;		private var _ct:ColorTransform;				public function VideoEcho(width:Number, height:Number)		{			super(width, height);			orient = NORMAL;			_mesh = new Array(4);			for (var i:uint=0; i<4; i++) {				_mesh[i] = new Pixel(0,0,0,0);			}			_ct = new ColorTransform();		}	 		public function set zoom(n:Number):void {			_zoom = n;		}				public function get zoom():Number {			return _zoom;		}				private function createMesh():void {			var n:int=0;			var orient:int = Math.floor(orient)%4;			var iz:Number = (_zoom == 0) ? 1 : 1.0/_zoom;			var lo:Number = 0.5 - 0.5*iz;			var hi:Number = 0.5 + 0.5*iz;			for (var v:int=0; v < 2; v++) {				for (var u:int=0; u < 2; u++) {					_mesh[n].u_t = (u == 0) ? lo : hi;					_mesh[n].v_t = (v == 0) ? lo : hi;					_mesh[n].x0 = u*_w;					_mesh[n].y0 = v*_h;					n++;				}			}						for (n=0; n < 4; n++) {				if ((orient%2) == 0) {					_mesh[n].u_t = 1.0 - _mesh[n].u_t;				}				if (orient > 2) {					_mesh[n].v_t = 1.0 - _mesh[n].v_t;				}			}		}				private function drawTriangle(source:BitmapData, i1:uint,i2:uint,i3:uint):void {			hurlTriangle(source,this,_mesh[i1],_mesh[i2],_mesh[i3]);		}				public function echo(source:BitmapData, dest:BitmapData = null):void {			//return;			var g:Graphics = this.graphics;            g.clear();            createMesh();            drawTriangle(source,0,1,2);            drawTriangle(source,1,3,2);			if (dest) {				_ct.alphaMultiplier = this.alpha;				dest.draw(this,null,_ct,'layer');			}        }			}}