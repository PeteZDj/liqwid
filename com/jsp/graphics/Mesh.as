/*       *      Copyright 2009 (c) Scott Penberthy, scottpenberthy.com. All Rights Reserved. *       *      This software is distributed under commercial and open source licenses. *      You may use the GPL open source license described below or you may acquire  *      a commercial license from scottpenberthy.com. You agree to be fully bound  *      by the terms of either license. Consult the LICENSE.TXT distributed with  *      this software for full details. *       *      This software is open source; you can redistribute it and/or modify it  *      under the terms of the GNU General Public License as published by the  *      Free Software Foundation; either version 2 of the License, or (at your  *      option) any later version. See the GNU General Public License for more  *      details at: http://scottpenberthy.com/legal/gplLicense.html *       *      This program is distributed WITHOUT ANY WARRANTY; without even the  *      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *       *      This GPL license does NOT permit incorporating this software into  *      proprietary programs. If you are unable to comply with the GPL, you must *      acquire a commercial license to use this software. Commercial licenses  *      for this software and support services are available by contacting *      scott.penberthy@gmail.com. * */ package com.jsp.graphics{	import flash.display.BitmapData;	import flash.display.Graphics;	import flash.display.Sprite;	import flash.geom.Matrix;	import flash.geom.Point;		public class Mesh extends uvSprite	{		protected var _mesh:Array;				// internal representation as an array		protected var _meshY:Number;			// columns in our mesh		protected var _meshX:Number;			// rows in our mesh		protected var _meshSize:Number;			// cached value for total number of pixels in the mesh		protected var _meshPt:Point;		protected var _wt:Number;				// width of source texture		protected var _ht:Number;				// height of source texture				public var mv_a:Number;		public var mv_r:Number;		public var mv_g:Number;		public var mv_b:Number;		public var mv_x:Number;		public var mv_dx:Number;		public var mv_y:Number;		public var mv_dy:Number;		public var mv_l:Number;				//		// Internal tools for faster referencing and blitting during texture		// mapping.		//				private var _tool:Sprite = new Sprite();		private var _texture:BitmapData;		private var _screen:BitmapData;						// Flash 10 tools for fast BLTing		private var _indices:Vector.<int>;		private var _vertices:Vector.<Number>;		private var _uvt:Vector.<Number>;			public function Mesh(rows:int, cols:int, width:Number, height:Number) 		{			super(width,height);			_meshX = Math.max(1,rows);			_meshY = Math.max(1,cols);			_wt = Math.max(1,width); 			_ht = Math.max(1,height);			init();		}				public function setTextureSize(width:Number, height:Number):void {			if (width == 0 || height == 0) {				trace("Bad texture size.");				return;			}			_wt = width;			_ht = height;			_iaspect = _ht/_wt;			reset();		}				override protected function afterResize():void {			reset();		}				private function init():void {			// The mesh starts at vertex 0 and increases to vertex _meshY*_meshX,			// numbering first at y=0,x=0 then incrementing x in each row.			//			createCommonValues();			createIndices();			fillMeshArray();			setupMotionVectors();		}				private function setupMotionVectors():void {			mv_r = mv_b = mv_g = 1.0;			mv_r = 0.25;			mv_a = 0.5;			mv_dx = mv_dy = 0.1;			_meshPt = new Point();			mv_l = 0.2;			mv_x = 6;			mv_y = 6;		}				private function mvclip(n:Number, lim:Number):Number {			if (n > lim) {				// preserve the fraction, as it is used to customize the motion vectors				return lim + (n-Math.floor(n));			}			else {				return n;			}		}				public function motionVectors(xCount:Number, yCount:Number, red:Number, green:Number, blue:Number, alpha:Number):void {			mv_x = mvclip(xCount, _meshX);			mv_y = mvclip(yCount, _meshY);			mv_r = red;			mv_g = green;			mv_b = blue;			mv_a = alpha;		} 									private function createCommonValues():void {			_meshSize = (_meshY+1)*(_meshX+1);			_mesh = new Array(_meshSize);			_tMat = new Matrix();  // for drawing, these are used at every vertex			_sMat = new Matrix();			_w2 = _w*0.5; 			_iw = (_w == 0) ? 0 : 1/_w;			_h2 = _h*0.5;			_ih = (_h == 0) ? 0 : 1/_h;		}				private function fillMeshArray():void {			//			// TODO do a quick iteration, then call reset() for DRY 			//			var count:Number = _meshSize;			for (var i:int=0; i < count; i++) _mesh[i] = new Pixel(0,0,0,0);			reset();		}				private function vertex(xIndex:int, yIndex:int):Object {			return _mesh[yIndex * (_meshX+1) + xIndex];		}				public function morph(time:Number):void {			//			// Morph the mesh at f(time)			//			var len:Number = _mesh.length;			for (var i:int=0; i<len; i++) _mesh[i].morph(time);					}				public function vertexMap(f:Function):void {			//			// Apply a function f to all vertices in the vertex			//			var len:Number = _mesh.length;			for (var i:int=0; i<len; i++) f(_mesh[i]);			}				public function reset():void {			//			// Reset the mesh to default values			//			var nVert:int = 0;			var vertex:Pixel;			var u:Number, v:Number;		// holds (u,v)			var xx:Number, yy:Number;		// holds (x,y)						for (var ym:Number=0; ym <= _meshY; ym++) {				v = (ym/_meshY);				yy = v*2.0 - 1.0;				for (var xm:Number=0; xm <= _meshX; xm++) {					u = (xm/_meshX);					xx = u*2.0 - 1.0;					vertex = _mesh[nVert];					vertex.u = u;					vertex.v = v;					vertex.x = xx;					vertex.y = yy;					vertex.x0 = (xx+1)*_w2;					vertex.y0 = (yy+1)*_h2;					vertex.i = nVert;					vertex.reset();					nVert++;				}			}			updateXY();		}				public function meshPoint(fx:Number, fy:Number, result:Point):Boolean {			//			// Locate a point on the mesh, then compute the gradient blend			// from all four corners, and store the values in the 'result'			// Point.			//			var y0:int = Math.floor(fy * _meshY);			var dy:Number = fy*_meshY - y0;			var x0:int = Math.floor(fx * _meshX);			var dx:Number = fx*_meshX - x0;			var x1:int = x0+1;			var y1:int = y0+1;						result.x = 0;			result.y = 0;						// is point off the mesh?			if (x0 < 0) return false;			if (y0 < 0) return false;			if (x1 > (_meshX + 1)) return false;			if (y1 > (_meshY + 1)) return false;						// its on the mesh, compute its coords within the mesh patch			// this is a four-point gradient where we blend values from			// each corner.  At the center we take 25% of everything, at a corner			// we get 100% ofthe corner, 0% of everything else.			var u:Number = _mesh[y0*(_meshX+1)+x0].u_t * (1-dx)*(1-dy);			var v:Number = _mesh[y0*(_meshX+1)+x0].v_t * (1-dx)*(1-dy);			u += _mesh[y0*(_meshX+1)+x1].u_t * (dx)*(1-dy);			v += _mesh[y0*(_meshX+1)+x1].v_t * (dx)*(1-dy);			u += _mesh[y1*(_meshX+1)+x0].u_t * (1-dx)*(dy);			v += _mesh[y1*(_meshX+1)+x0].v_t * (1-dx)*(dy);			u += _mesh[y1*(_meshX+1)+x1].u_t * (dx)*(dy);			v += _mesh[y1*(_meshX+1)+x1].v_t * (dx)*(dy);						result.x = u;			result.y = 1.0 - v;			//trace("MeshPt("+fx+","+fy+") = ("+u+","+v+") with dx="+dx+" dy="+dy	);			//trace("Mesh point @ ("+x0+","+y0+")");			return true;		}				//		// Flash 10 enhancements		//				public function textureMap(texture:BitmapData, screen:BitmapData):void {			var g:Graphics = _tool.graphics;			g.clear();			updateUV();			g.beginBitmapFill(texture,null,true,true);			g.drawTriangles(_vertices,_indices,_uvt);			g.endFill();			screen.draw(_tool);		}				private function createIndices():void {			var nVert:Number;			var i1:Number;			var i2:Number;			var i3:Number;			var i4:Number;			var count:Number = _meshSize*2;			_indices = new Vector.<int>;			_vertices = new Vector.<Number>(count);			_uvt = new Vector.<Number>(count);			for (var ym:int=0; ym < _meshY; ym++) {				nVert = ym*(_meshX+1);				for (var xm:int=0; xm < _meshX; xm++) {					i1 = nVert;					i2 = nVert+1;					i3 = i2 + _meshX ;					i4 = i3 + 1;					_indices.push(i1, i2, i3,  i2,i4,i3);					nVert++;				}			}		}				private function updateUV():void {			var count:Number = _meshSize*2;			for (var i:int=0, nVert:int=0; i < count;) {				var p:Pixel = _mesh[nVert++];				_uvt[i++] = p.u_t;				_uvt[i++] = p.v_t;			}		}				private function updateXY():void {			var count:Number = _meshSize*2;			for (var i:int=0, nVert:int=0; i < count;) {				var p:Pixel = _mesh[nVert++];				_vertices[i++] = p.x0;				_vertices[i++] = p.y0;			}		}				//		// Old school bitmap twiddling using matrices in Flash vs. the Flash VM		//							public function textureMapv9(texture:BitmapData, screen:BitmapData):void {			var g:Graphics = _tool.graphics;			var nVert:int = 0;			var i1:Number;			var i2:Number;			var i3:Number;			var i4:Number;			            g.clear();            _texture = texture;            _screen = screen;			g.lineStyle();			for (var ym:int=0; ym < _meshY; ym++) {				nVert = ym*(_meshX+1);				for (var xm:int=0; xm < _meshX; xm++) {					i1 = nVert;					i2 = nVert+1;					i3 = i2 + _meshX ;					i4 = i3 + 1;					drawTriangle(i1,i2,i3);					drawTriangle(i2,i4,i3);					nVert++;				}			}			_screen.draw(_tool);						_texture = _screen = null;		}				private function drawTriangle(i0:int, i1:int, i2:int):void {			// Draw a triangle from three mesh vertices (p0,p1,p2)			// We assume _texture contains the texture 			// We draw on _tool			//			// return;  /*** turn off blitting ***/			var p0:Pixel = _mesh[i0];			var p1:Pixel = _mesh[i1];			var p2:Pixel = _mesh[i2];						hurlTriangle(_texture, _tool, p0,p1,p2);			return;		}				public function drawMotionVectors(dest:BitmapData):void {			// draw motion vectors			if (mv_a < 0.005) {				//trace("Zero alpha motion vectors!");				return;			}			var g:Graphics = _tool.graphics;			var ha:Number = _h * _aspect;			var nX:int = Math.floor(mv_x);			var nY:int = Math.floor(mv_y);			var dx:Number = (mv_x - nX);			var dy:Number = (mv_y - nY);		    //if (nX > 32) { nX = 32; dx=0; }			//if (nY > 24) { nY = 24; dy=0; }			if ((nX > 0) && (nY > 0)) {				g.clear();				g.lineStyle(0,makeColor(mv_r,mv_g,mv_b,0),mv_a);				//trace("Mv color="+mvColor());								var dx2:Number = 0.05;//mv_dx;				var dy2:Number = 0.05;//mv_dy;				var len_mult:Number = mv_l;				var min_len:Number = 2*_iw;  // (1 pixel)				if (dx < 0) dx = 0;				if (dy < 0) dy = 0;				if (dx > 1) dx = 1;				if (dy > 1) dy = 1;				for (var ym:int=0; ym < nY; ym++) {					// evenly space out y values, with a border of 25% (12.5, 12.5)					var fy:Number = (ym + 0.25)/(nY + dy + 0.25 - 1.0);									// move y by specified dy					fy -= dy2;					if (fy > 0.0001 && fy < 0.9999) {  					  var n:int = 0;					  for (var xm:int=0; xm < nX; xm++) {						  // evenly space out x values, with a border of 25%						  var fx:Number = (xm + 0.25)/(nX + dx + 0.25 - 1.0);						  // move x by specified dx						  fx -= dx2;						  if ((fx > 0.0001 && fx < 0.9999) && meshPoint(fx,fy,_meshPt)) {							  // enforce min lengths							  var pt:Point = _meshPt;						      var dx3:Number = (pt.x - fx)*len_mult;							  var dy3:Number = (pt.y - fy)*len_mult;							  var len:Number = Math.sqrt(dx3*dx3 + dy3*dy3);							  if (len > min_len) {								  // do nothing							  }							  else if (len > 0.001) {								  len = min_len / len;								  dx3 *= len;								  dy3 *= len;							  }							  else {								  dx3 = min_len;								  dy3 = min_len;							  }							  pt.x = fx + dx3;							  pt.y = fy + dy3;							 // trace("MV "+count+": ("+fx+","+fy+") to ("+pt.x+","+pt.y+") len="+len+"  min="+min_len);							  var x1:Number = Math.floor(fx*_w); //((fx*2)-1)*_w;							  var y1:Number = Math.floor(fy*ha); //((fy*2)-1)*ha;							  var x2:Number = Math.floor(pt.x*_w); //((pt.x*2)-1)*_w;							  var y2:Number = Math.floor(pt.y*ha); //((pt.y*2)-1)*ha;							 // trace("MV "+count+": ("+x1+","+y1+") to ("+x2+","+y2+")");							  g.moveTo(x1,y1);							  g.lineTo(x2,y2);						  }					  }					}					dest.draw(_tool);				}								}		}	}}