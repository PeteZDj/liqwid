/*       *      Copyright 2009 (c) Scott Penberthy, scottpenberthy.com. All Rights Reserved. *       *      This software is distributed under commercial and open source licenses. *      You may use the GPL open source license described below or you may acquire  *      a commercial license from scottpenberthy.com. You agree to be fully bound  *      by the terms of either license. Consult the LICENSE.TXT distributed with  *      this software for full details. *       *      This software is open source; you can redistribute it and/or modify it  *      under the terms of the GNU General Public License as published by the  *      Free Software Foundation; either version 2 of the License, or (at your  *      option) any later version. See the GNU General Public License for more  *      details at: http://scottpenberthy.com/legal/gplLicense.html *       *      This program is distributed WITHOUT ANY WARRANTY; without even the  *      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *       *      This GPL license does NOT permit incorporating this software into  *      proprietary programs. If you are unable to comply with the GPL, you must *      acquire a commercial license to use this software. Commercial licenses  *      for this software and support services are available by contacting *      scott.penberthy@gmail.com. * */package com.jsp.graphics{	import flash.display.Graphics;	import flash.display.Sprite;	public class Path extends Sprite	{		protected var _values:Array;		protected var _size:Number;		protected var _w:Number;		protected var _h:Number;				public var r:Number = 1.0;				// red content, 0-1		public var g:Number = 1.0;				// green content, 0-1		public var b:Number = 1.0;				// blue content, 0-1		public var a:Number = 1.0;				// alpha 0-1		public var thick:Number = 1.0;			// thickness, in pixels		public var dots:Boolean = false;		// whether to use dots				public function Path(numPixels:Number=256, width:Number=400, height:Number=100)		{			_size = numPixels;			_w = width;			_h = height;			init();		}				public function setSize(width:Number, height:Number):void {			_w = width;			_h = height;			render();		}				private function init():void {			_values = new Array(_size);			for (var i:int=0; i < _size; i++) {				_values[i] = new Pixel(0,0,0,0);			}		}				public function clear():void {			for (var i:int=0; i < _size; i++) {				var p:Pixel = _values[i];				p.u = 0;				p.v = 0;				p.x = 0;				p.y = 0;			}		}				private function sample(numbers:Array, index:Number, stride:Number):Number {			if (stride < 1) return numbers[Math.floor(index)];			var n:Number = 0;			var i:Number = Math.floor(stride);			while (i > 0) {				n += numbers[index++];				i--;			}			return n/stride;		}				public function plot(numbers:Array, length:int = -1):void {			//			// Turn an array of numeric values into a Path for displaying			// on a screen.			//			var len:Number = (length < 1) ? numbers.length : length;			var stride:Number = (len-1)/_size;			var s:Number = _size;			var p:Pixel;			var n:Number;			var i:Number, n_i:Number;			var max:Number, min:Number, irange:Number;			var iSamp:Number = 1.0/s;			var u:Number;			var range:Number;						if (len == 0) {				clear();				return;			}			max = min = numbers[0];			for (i=0, n_i=0, u=0; i < s; i++, n_i += stride, u += iSamp) {				p = _values[i];				p.u = u;				p.v = n = sample(numbers,n_i,stride); 				//trace("sample #"+i+"="+n);				if (n < min) min = n;				if (n > max) max = n;			}						range = (max - min);			if (range == 0) {				irange = 1.0;			}			else {				irange = 1.0/range;			}						// TODO change this so that the plot centers in the plot area,			// TODO versus covering the full range.  this will put a flatline			// TODO as a straight line down the vertical middle, vs. a flatline			// TODO that hugs the x axis.						for (i=0; i < s; i++) {				p = _values[i];				p.v = 1.0 - (p.v - min)*irange;				p.x = p.u*_w;				p.y = p.v*_h;			}			_rawMin = min;			_rawRange = range;			render();		}				private var _rawMin:Number;		private var _rawRange:Number;		public function uvPlot(numbers:Array, length:int = -1):void {			var len:Number = (length < 1) ? numbers.length : length;			var stride:Number = (len-1)/_size;			var s:Number = _size;			var p:Pixel;			var n:Number;			var i:Number, n_i:Number;			var iSamp:Number = 1.0/s;			var u:Number;						if (len == 0) {				clear();				return;			}						for (i=0, n_i=0, u=0; i < s; i++, n_i += stride, u += iSamp) {				p = _values[i];				p.u = u;				p.v = n = sample(numbers,n_i,stride); 			}						for (i=0; i < s; i++) {				p = _values[i];				p.x = p.u*_w;				p.y = p.v*_h;			}			_rawMin = 0;			_rawRange = 1.0;			render();		}		public function render(length:int = -1, filled:Boolean = false, dots:Boolean = false):void {			var g:Graphics = this.graphics;			var len:Number = (length < 1) ? _size : length;			var p:Pixel;			var color:uint = makeColor();						g.clear();			if (filled) {				g.beginFill(color,a*0.2);			}			g.lineStyle(thick, color, a);						p = _values[0];			g.moveTo(p.x,p.y);			for (var i:int=0; i < len; i++) {				p = _values[i];				if (dots) {					g.beginFill(color,a);					g.drawCircle(p.x,p.y,thick*2);					g.endFill();				}				if (filled || !dots) {					g.lineTo(p.x,p.y);				}			}		}				override public function toString():String {			var len:int = _values.length;			var min:Number, max:Number, stdev:Number, mean:Number;			var n:Number;			if (len == 0) {				return "No data.";			}			min=max=mean=_values[0].v;			stdev=0;			for (var i:int=1; i < len; i++) {				n = _values[i].v*_rawRange + _rawMin;				if (n < min) min=n;				if (n > max) max=n;				mean += n;			}			mean = mean/len;			for (i=0; i < len; i++) {				n = _values[i].v*_rawRange + _rawMin;				stdev += Math.pow((n-mean),2);			}			stdev = Math.sqrt(stdev / len);						_min = _min*0.92 + 0.08*min;  // not quite			_max = _max*0.92 + 0.08*max;			_std = _std*0.92+stdev*0.08;			_mean = _mean*0.92+mean*0.08;			return "["+_min.toFixed(3)+","+_max.toFixed(3)+"] "+_mean.toFixed(3)+" +/- "+_std.toFixed(5);		}				private var _min:Number=0;		private var _max:Number=0;		private var _mean:Number=0;		private var _std:Number=0;				private function makeColor():uint {			if (r > 1) r=1;			if (g > 1) g=1;			if (b > 1) b=1;			if (a > 1) a=1;			if (r < 0) r=0;			if (g < 0) g=0;			if (b < 0) b=0;			if (a < 0) a=0;			return ((Math.floor(a*255) & 0xFF) << 24) |			       ((Math.floor(r*255) & 0xFF) << 16) |			       ((Math.floor(g*255) & 0xFF) << 8) | 				   (Math.floor(b*255) & 0xFF);		}				public function setUV(index:int, u:Number, v:Number):void {			// 			// CAUTION - NO ERROR CHECKING FOR SPEED			//			//if (index >= _size) index = _size-1;			//if (index < 0) index = 0;			var p:Pixel = _values[index];						p.u = u;			p.v = v;			p.x = u*_w;			p.y = v*_h;		}				public function copyUV(toIndex:int, fromIndex:int):void {			var pTo:Pixel = _values[toIndex];			var pFrom:Pixel = _values[fromIndex];						pTo.u = pFrom.u;			pTo.v = pFrom.v;			pTo.x = pTo.u*_w;			pTo.y = pTo.v*_h;		}			}}