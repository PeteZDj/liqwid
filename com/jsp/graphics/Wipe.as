/*       *      Copyright 2009 (c) Scott Penberthy, scottpenberthy.com. All Rights Reserved. *       *      This software is distributed under commercial and open source licenses. *      You may use the GPL open source license described below or you may acquire  *      a commercial license from scottpenberthy.com. You agree to be fully bound  *      by the terms of either license. Consult the LICENSE.TXT distributed with  *      this software for full details. *       *      This software is open source; you can redistribute it and/or modify it  *      under the terms of the GNU General Public License as published by the  *      Free Software Foundation; either version 2 of the License, or (at your  *      option) any later version. See the GNU General Public License for more  *      details at: http://scottpenberthy.com/legal/gplLicense.html *       *      This program is distributed WITHOUT ANY WARRANTY; without even the  *      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *       *      This GPL license does NOT permit incorporating this software into  *      proprietary programs. If you are unable to comply with the GPL, you must *      acquire a commercial license to use this software. Commercial licenses  *      for this software and support services are available by contacting *      scott.penberthy@gmail.com. * */package com.jsp.graphics{	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.Graphics;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.TimerEvent;	import flash.filters.BlurFilter;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.utils.Timer;	import flash.utils.getTimer;	public class Wipe extends Sprite	{		protected var _source:BitmapData;				// the original source bitmap data		protected var _target:BitmapData;				// the original target bitmap data		protected var _raw:BitmapData;				protected var _tool:BitmapData;					// compositing tool		protected var _rect:Rectangle;					// bounding rectangle the covers source & target				protected var _sourceBitmap:Bitmap;				// what it says		protected var _sourceMask:Sprite;				// wipe's write to the mask, which we composite		protected var _targetBitmap:Bitmap;				// what it says		protected var _targetMask:Sprite;				// wipe's write to the mask, which we composite				protected var _w:Number;					// width of child		protected var _h:Number;					// height of child						private var _tdx:Number;					// x offset in pixels for target texture, which sits in middle of the tween		private var _tdy:Number;					// y offset		private var _sdx:Number;					// x offset, source		private var _sdy:Number;					// y offset, source				protected var _rx:Number;					// number of times to repeat in x direction		protected var _ry:Number;					// number of times to repeat in y direction		protected var _dir:Number;					// direction 1 or -1				protected var _mask:Sprite;					// current mask.  helper variable for uv() shortcuts		protected var _image:Bitmap;				// current image.		protected var _p:Number;					// current progress.				protected var _config:Object;				// original configuration				private var _tMat:Matrix = new Matrix();	// a handy matrix for compositing		private var _pt:Point = new Point();		// a handy point for copying pixels		private var _blur:BlurFilter;				// we blur the masks just a tad for a professional look			private var _filters:Array;					// we create the array of filters just once				// TODO handle transition colors		// TODO handle start, end time		// TODO I think we can get rid of the target mask?				public function Wipe(config:Object) 		{						_config = config;			_source = config.source;			_target = config.target;			_rx = config.horiz ? config.horiz+1 : 1;			_ry = config.vert ? config.vert+1 : 1;			_dir = config.dir ? config.dir : 1;			_blur = new BlurFilter();			_filters = [_blur];			init();		}				public function dispose():void {			_raw.dispose();			_source.dispose();			_target.dispose();			_tool.dispose();		}		public function repeat(horiz:Number, vert:Number):void {			_rx = Math.floor(horiz)+1;			_ry = Math.floor(vert)+1;			//trace("..repeating "+_rx+" by "+_ry);		}				public function set direction (n:int):void {			var od:int = _dir;			if (n > 0) _dir = 1;			else _dir = -1;			if (od != _dir) {				// swap!				var bmd:BitmapData = _target;				var s:Sprite = _targetMask;				var ody:Number = _tdy, odx:Number = _tdx;				_target = _source				_targetMask = _sourceMask;				_tdx = _sdx;				_tdy = _sdy;								_source = bmd;				_sourceMask = s;				_sdx = odx;				_sdy = ody;								_sourceBitmap = new Bitmap(_source);				_targetBitmap = new Bitmap(_target);								update(0);			}		}				private function directional(n:Number):Number {			if (n < 0) n=0;			if (n > 1) n=1;			if (_dir < 0) {				return 1 - n;			}			else {				return n;			}		}				private function init():void {						if (_dir == -1) {				var tmp:BitmapData = _source;				_source = _config.source = _target;				_target = _config.target = tmp;			}						_w = Math.max(_source.width, _target.width);			_h = Math.max(_source.height, _target.height);			//trace("Wipe effect is "+_w+"x"+_h);				// Compositing tools			_rect = new Rectangle(0,0,_w,_h);			_tool = new BitmapData(_w, _h, true, 0x000000);			_raw = new BitmapData(_w, _h, false, 0x000000);					_tMat.identity();						// Replace transparent areas in the target with black			_targetMask = new Sprite();		    _tMat.tx = _tdx = 0.5*(_w - _target.width);			_tMat.ty = _tdy = 0.5*(_h - _target.height);			_target = new BitmapData(_w,_h,false,0x000000);			_target.draw(_config.target, _tMat);						// Replace transparent areas in the source with black			_tMat.identity();			_sourceMask = new Sprite();			_tMat.tx = _sdx = 0.5*(_w - _source.width);			_tMat.ty = _sdy = 0.5*(_h - _source.height);			_source = new BitmapData(_w,_h,false,0x000000);			_source.draw(_config.source, _tMat);			_sourceBitmap = new Bitmap(_source);			_targetBitmap = new Bitmap(_target);						update(0);		}				public function clear():void {			_targetMask.graphics.clear();			_sourceMask.graphics.clear();			//_raw.fillRect(_rect,0x000000);		}				protected function identity(mask:Sprite, progress:Number = 1):void {			var g:Graphics = mask.graphics;			g.clear();			g.beginFill(0xffffff);			g.drawRect(0,0,_w,_h);			g.endFill();		}				protected function circle(mask:Sprite, progress:Number = 1):void {			var g:Graphics = mask.graphics;			g.clear();			g.beginFill(0xffffff);			g.drawCircle(_w/2,_h/2,progress*Math.max(_w,_h));			g.endFill();		}				public function tween(percent:Number):void {			//			// Do the magic in here, combining the source			// and target bitmaps into one, representing 			// 'percent' complete.  'percent' ranges from 0 to 1.			//			// The base class will fade the target over the			// source.			//			var p:Number = directional(percent);			tweenSource(_sourceMask, _sourceBitmap, p);			tweenTarget(_targetMask, _targetBitmap, p);		}				public function tweenSource(mask:Sprite, image:Bitmap, percent:Number):void {			identity(mask, (1-percent));  			image.alpha = 1-percent;		}				public function tweenTarget(mask:Sprite, image:Bitmap, percent:Number):void {			identity(mask, percent);			image.alpha = percent;		}				public function compose(progress:Number):void {			//			// Create the underlying bitmap graphic			//			var sx:Number = 1/_rx;			var sy:Number = 1/_ry;			var xo:Number = (_rx == 1) ? 0 : 4;			var yo:Number = (_ry == 1) ? 0 : 4;			var xStride:Number = (_w-xo)/_rx;			var yStride:Number = (_h-yo*(_h/_w))/_ry;						// get a fresh copy of the source bitmap (with a border)			if (progress < 1) {				_tool.copyPixels(_source,_rect,_pt);							// cut out holes from the source bitmap				_tMat.identity();				_tMat.scale(sx,sy);				_targetMask.filters = _filters;							for (var oy:Number=0; oy < _h; oy += yStride) {					for (var ox:Number=0; ox < _w; ox += xStride) {						_tMat.tx = ox;						_tMat.ty = oy;						_tool.draw(_targetMask,_tMat,null,'erase',null,true);					}				}			}			else {				_tool.fillRect(_rect,0x000000);			}						// lay down the target bitmap (with a border)			_raw.copyPixels(_target,_rect,_pt);						// draw the hole-filled source bitmap, over the target			// the target will "show through"			_raw.copyPixels(_tool,_rect,_pt);		}				public function get raw():BitmapData {			//			// Return a raw bitmapdata object for blitting to the screen			//			return _raw;		}				//		// The wipe animation, ~ 20fps		//				private var _d:Number;		private var _t:Number;		private var _t0:Number;		private var _timer:Timer = null;				public function start(duration:Number = 1.0):void {			if (_timer == null) {				_timer = new Timer(50);				_timer.addEventListener(TimerEvent.TIMER, wipeTic);			}			_raw.fillRect(_rect,0x000000);			//_raw.fillRect(_rect,(Math.floor(255*Math.random()) << Math.round(Math.random()*16)));			_d = duration*1000;			_t0 = getTimer();			update(0);			_timer.start();		}				protected function update(p:Number):void {			_raw.lock();			clear();			tween(p);			compose(directional(p));			_raw.unlock();		}				protected function wipeTic(e:TimerEvent):void {			var p:Number;						_t = getTimer() - _t0;			p = _t/_d;			//trace("["+_t+"]: wipe tween "+p);			if (p > 1) p = 1;			update(p);			if (p == 1) {				//_timer.removeEventListener(TimerEvent.TIMER, wipeTic);				_timer.stop();				//_raw = _target;				dispatchEvent(new Event(Event.COMPLETE, true, true));			}		}				//		// Helper functions		//				protected function uvTo(u:Number, v:Number):void {			_mask.graphics.lineTo(u*_w, v*_h);		}				protected function uv(u:Number, v:Number):void {			_mask.graphics.moveTo(u*_w, v*_h);		}				protected function box(u:Number, v:Number, w:Number, h:Number):void {			var g:Graphics = _mask.graphics;			g.beginFill(0xffffff);			g.drawRect(u*_w, v*_h, w*_w, h*_h);			g.endFill();		}				protected function path(uv:Array, w:Number, h:Number):void {			var g:Graphics = _mask.graphics;			var len:int = uv.length;			var u:Number, v:Number;						g.beginFill(0xffffff);			u = uv[0].u;			v = uv[1].v;			g.moveTo(u*w, v*h);			for (var i:int=1; i < len; i++) {				u = uv[i].u;				v = uv[i].v;				g.lineTo(u*w,v*h);			}			u = uv[0].u;			v = uv[0].v;			g.lineTo(u*w,v*h);			g.endFill();		}			}}