/*       *      Copyright 2009 (c) Scott Penberthy, scottpenberthy.com. All Rights Reserved. *       *      This software is distributed under commercial and open source licenses. *      You may use the GPL open source license described below or you may acquire  *      a commercial license from scottpenberthy.com. You agree to be fully bound  *      by the terms of either license. Consult the LICENSE.TXT distributed with  *      this software for full details. *       *      This software is open source; you can redistribute it and/or modify it  *      under the terms of the GNU General Public License as published by the  *      Free Software Foundation; either version 2 of the License, or (at your  *      option) any later version. See the GNU General Public License for more  *      details at: http://scottpenberthy.com/legal/gplLicense.html *       *      This program is distributed WITHOUT ANY WARRANTY; without even the  *      implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *       *      This GPL license does NOT permit incorporating this software into  *      proprietary programs. If you are unable to comply with the GPL, you must *      acquire a commercial license to use this software. Commercial licenses  *      for this software and support services are available by contacting *      scott.penberthy@gmail.com. * */  // TODO Blend presets when they change, Geiss style // TODO optimize this.  The Milkdrop variable scoping is, um, unique.package com.jsp.plugin {	import flash.display.BitmapData;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.utils.Timer;	import flash.utils.getTimer;	import com.jsp.audio.MusicAnalyzer;	import com.jsp.audio.Wave;	import com.jsp.calculator.*;	import com.jsp.graphics.Border;	import com.jsp.graphics.Frame;	import com.jsp.graphics.uvPolygon;	import com.jsp.graphics.uvSprite;	import com.jsp.graphics.Shader;	import com.jsp.graphics.SlideShow;	import com.jsp.graphics.Chart;	import com.jsp.video.Webcam;	import com.jsp.feeds.PresetFeed;	import com.jsp.events.LiqwidEvent;	import com.jsp.graphics.Pixel;	import com.jsp.config.MilkdropConfig;	public class Milkdrop extends Visualizer {		private var _exp:Expression;		private var _config:MilkdropConfig;		private var _cFrame:Calculator;		private var _snapshot:Array=null;		private var _cShapes:Array;		private var _shapeInit:Array;		private var _cTool:Calculator;		private var _monitor:Chart;		/** This function is automatically called by the player after the plugin has loaded. **/		public function Milkdrop(w:Number, h:Number):void {			super(w,h);			//trace("Creating milkdrop");			_cFrame = new Calculator();			_cTool = new Calculator();			_monitor = new Chart('unknown',300,90);			_monitor.visible = false;			addChild(_monitor);			_config = new MilkdropConfig();		}			override protected function tic():void {			readFrame();			_cFrame.eval();			writeFrame();			doShapes();			_frame.render(_t);			if (_config.needCamera) useCamera();			if (_config.needSlides) {				if (_show) _show.start();			}			else {				// let's be smarter about when to call this please				if (_show) _show.stop();			}			if (_monitor.visible) _monitor.plot();		}				override protected function updatePreset():void {			//			// _program will have {author:, title:, preset:} attributes			//			//trace("Updating preset in Milkdrop.");			if (_program == null || _program.preset == null) return;			//trace("Using preset:"+_program.preset);			compilePreset();			createFirstFrame();			addFrameShader();			addPixelShader();			addShapeShaders();			checkMonitor();			if (_api) _api.sendEvent('PRESET',{	title: _program.title,									 			author: _program.author,												preset: _exp.raw});		}		private function snapshotFrame():void {			var m:Array=_cFrame.memory;			_snapshot = m.slice(0);		}				override protected function doCommand(type:String, data:*):void {			switch (type) {				case 'SET_PARM':					if (_api) _api.sendEvent('ECHO','set '+data.parm+' to '+data.value);					_config.changePreset(data.parm, data.value, _frame, _wave, _ma);					snapshotVar(data.parm,data.value);					break;			}		}				private function snapshotVar(name:String, value:Number):void {			if (!_snapshot) return;  // what should we do?			var canonical = name.toLowerCase();			var frameVar:String = _config.mapToFrameVar(name);			_snapshot[Token.ize(frameVar)] = value;		}		private function restoreFrame():void {			if (_snapshot==null) {				return;			}			var m:Array = _cFrame.memory;			var len1:int = Math.min(_snapshot.length,Milk.FRAME_END);			for (var i:uint = 0; i<len1; i++) {				m[i]=_snapshot[i];			}		}		private function compilePreset():void {			// _exp now has 			//			// 1) global variables in the top-level expression			// 2) per_frame_ bytecodes to run each frame			// 3) per_pixel_ bytecodes to run each pixel			// ...			_exp=new Expression(_program.preset);			_exp.compile();			//_exp.showJit();			_cFrame.expandMemory();		}				private function checkMonitor():void {			var mvar:String = _exp.monitor(Milk.frame.code);			//trace("FRAME MONITOR mvar="+mvar);			if (mvar) {				_monitor.title = mvar;				_monitor.visible = true;			}			else {				_monitor.visible = false;			}		}		private function createFirstFrame():void {			_config.writeCalcPresets(_cFrame);			_cFrame.bytecodes = _exp.bytecodes;// global vars			_cFrame.eval();			_config.writePresets(_cFrame, _frame, _wave, _ma);			_cFrame.bytecodes = _exp.blockCodes(Milk.frame.init);// init routine			_cFrame.eval();			_monitor.clear();			snapshotFrame();		}		private function addFrameShader():void {			// initialize and load up our frame shader			var frameShader:Array=_exp.blockCodes(Milk.frame.code);			if (frameShader) {				//trace("Frame shader:");				//_exp.showOps(frameShader);			} else {				_exp = new Expression(mypreset(_program.preset));				_exp.compile();				_cFrame.expandMemory();				_cFrame.bytecodes = _exp.blockCodes(Milk.frame.code);				//trace("Frame shader:");				//_exp.showOps(_cFrame.bytecodes);			}			_cFrame.bytecodes = frameShader;			_cFrame.eval();		}		private function addPixelShader():void {			// Initialize and load up our pixel shader			var pixelShader:Array = _exp.blockCodes(Milk.pixel.code);			if (pixelShader) {				//trace("Pixel shader:");				//_exp.showOps(pixelShader);			}			_shader.storeCodes(pixelShader);			_frame.useShader(_shader);			writeFrame();		}				private function addShapeShaders():void {			// Initialize and load up each shape			var shapeCodes:Array;			var shapeShader:Array;			var shapeInit:Array;			var len:Number = Milk.NUM_SHAPES;						_cShapes = new Array();			_shapeInit = new Array();			_cTool.clear();			for (var i:uint=0; i < len; i++) {				_frame.shape(i).active = false;				shapeCodes = _exp.blockCodes(Milk.shape[i].code);				shapeInit = _exp.blockCodes(Milk.shape[i].per_frame_init);				shapeShader = _exp.blockCodes(Milk.shape[i].per_frame);							if (shapeCodes) {					_cTool.bytecodes = shapeCodes;					_cTool.eval();					if (_cTool.lookup('enabled') == 1) {						//trace("Adding shape "+i);						var cs:Calculator = new Calculator();						_cShapes.push(cs);						cs.clear();						cs.bytecodes = shapeCodes;						cs.eval();						if (shapeInit) {							cs.bytecodes = shapeInit;							cs.eval();						}						_shapeInit.push(cs.memory.slice(0));						cs.bytecodes = shapeShader;						//trace("\n**SHAPE "+i+" SHADER**\n");						//_exp.showOps(shapeShader);					}				}			}		}				private function doShapes():void {			for (var i:int=0; i < _cShapes.length; i++) {				var c:Calculator = _cShapes[i];				var m:Array = c.memory;				var shape:uvPolygon = _frame.shape(i);						c.eval();				shape.active = true;				shape.sides = m[Milk.SIDES];				shape.rad = m[Milk.RAD];				shape.tex_angle = m[Milk.TEX_ANG];				shape.tex_zoom = m[Milk.TEX_ZOOM];				shape.ang = m[Milk.ANG];				shape.inner(m[Milk.R],m[Milk.G],m[Milk.B],m[Milk.A]);				shape.outer(m[Milk.R2],m[Milk.G2],m[Milk.B2],m[Milk.A2]);				shape.border(m[Milk.BORDER_R],m[Milk.BORDER_G],m[Milk.BORDER_B],m[Milk.BORDER_A]);				shape.uv(m[Milk.X],m[Milk.Y]);								shape.progress = _t;				//trace("Shape "+i+" x="+m[Milk.X]+" y="+m[Milk.Y]+" t="+m[Milk.TIME]+" xx="+c.lookup('xx'));				//trace("d="+c.lookup('d')+" rad="+m[Milk.RAD]+" amp="+m[Milk.AMP]);								_config.needVideo = _config.needSlides = _config.needCamera = shape.textured = false;				m[Milk.TEXTURED]=2;				switch (m[Milk.TEXTURED]) {					case 1:						if (_frame.raw) shape.useTexture(_frame.raw);						break;											case 2:									if (_show) {							if (_show.raw) shape.useTexture(_show.raw);							_config.needSlides = true;						}						break;					case 3:						if (!_cam) {							_config.needCamera = true;							break;						}						else if (_cam.raw) {							shape.useTexture(_cam.raw);						}						break;					case 3:						_config.needVideo = true;						//trace("Shape: Video support not yet implemented.");						// show a video!						break;				}								// tex rotation?			}		}									private function readFrame():void {			var m:Array = _cFrame.memory;			restoreFrame();			_frame.motionVectors = _config.useMotionVectors || (m[Milk.MV_A] > 0);			if (_frame.motionVectors && m[Milk.MV_A] == 0) m[Milk.MV_A] = 1.0;			if (!_frame.motionVectors && m[Milk.MV_A] > 0) m[Milk.MV_A] = 0;			_wave.progress=_t;// TODO rename wave.progress to wave.time			m[Milk.FPS]= (_t == 0) ? 15 : (_config.frameNum/_t);			m[Milk.TIME]=_t;			m[Milk.FRAME]=_config.frameNum;			m[Milk.MOUSE_X] = (mouseX - _w2) / _w2;			m[Milk.MOUSE_Y] = (mouseY - _h2) / _h2;			m[Milk.PROGRESS]=_progress;			m[Milk.BASS]=_ma.bass;			m[Milk.MID]=_ma.mid;			m[Milk.TREBLE]=_ma.treble;			m[Milk.BASS_ATT]=_ma.bass_att;			m[Milk.MID_ATT]=_ma.mid_att;			m[Milk.TREBLE_ATT]=_ma.treb_att;			m[Milk.AMP]=_ma.amp;			m[Milk.MESHX] = 16;			m[Milk.MESHY] = 9;		}		private function writeFrame():void {			var m:Array=_cFrame.memory;			_config.frameNum++;			// decay			_frame.decay=m[Milk.DECAY];			_frame.echoAlpha=m[Milk.VE_ALPHA];			_frame.echoOrient=m[Milk.VE_ORIENT];			_frame.echoZoom=Math.min(1000,Math.max(0.001,m[Milk.VE_ZOOM]));			_frame.echo = (m[Milk.VE_ALPHA] > 0);			// inner border			_border.inner(m[Milk.IB_R],m[Milk.IB_G],m[Milk.IB_B],m[Milk.IB_A],m[Milk.IB_SIZE]);			// outer border			_border.outer(m[Milk.OB_R],m[Milk.OB_G],m[Milk.OB_B],m[Milk.OB_A],m[Milk.OB_SIZE]);			// wave properties			var wa:Number = m[Milk.WAVE_A];			if (_config.modWaveAlphaByVolume) wa *= (_ma.amp - _config.aStart)/(_config.aEnd - _config.aStart);			if (wa < 0) wa=0;			if (wa > 1) wa=1;			if (wa < 0.1) wa = 0.1;			_wave.setColor(m[Milk.WAVE_R],m[Milk.WAVE_G],m[Milk.WAVE_B],wa);			_wave.mode=m[Milk.WAVE_MODE];			_wave.uv(m[Milk.WAVE_X], m[Milk.WAVE_Y]);			_wave.setLevels(m[Milk.BASS], m[Milk.MID], m[Milk.TREBLE]);			_wave.thick = m[Milk.WAVE_THICK] ? 4 : 1;			_wave.mystery=m[Milk.WAVE_MYSTERY]; 			_wave.sample(_ma.L, _ma.R, m[Milk.WAVE_MODE]);			//trace("Wave "+_wave.mode+" ("+_wave.r+","+_wave.g+","+_wave.b+") @ ("+_wave.u+","+_wave.v+") alpha="+_wave.a+" scale="+_wave.scale);			// motion vector properties			_shader.motionVectors(m[Milk.MV_X],			 	 m[Milk.MV_Y],			 	 m[Milk.MV_R],			 	 m[Milk.MV_G],			 	 m[Milk.MV_B],			 	 m[Milk.MV_A]);			_shader.mv_l = Math.min(m[Milk.MV_L],10);			_shader.mv_dx = m[Milk.MV_DX];			_shader.mv_dy = m[Milk.MV_DY];						if (_monitor.visible) {				//trace("monitor="+m[Milk.MONITOR]);				_monitor.track(m[Milk.MONITOR]);			}			// Update our shaders			copyPixelVars(_shader.memory);			if (_cShapes) prepareShapeShaders();			//if (m[Milk.TIME] > 0) trace("fps ="+m[Milk.FRAME]/m[Milk.TIME]);		}				private function prepareShapeShaders():void {			// TODO optimize me			for (var i:int=0; i < _cShapes.length; i++) {				var sm:Array = _cShapes[i].memory;				copyReadOnlyVars(sm);				copyTVars(sm);			}		}		private function copyPixelVars(to:Array):void {			var from:Array=_cFrame.memory;			var start:Number=Milk.PIXEL_START;			var end:Number=Milk.PIXEL_END;			for (var i:uint=start; i <= end; i++) {				to[i]=from[i];			}		}				private function copyReadOnlyVars(to:Array):void {			var from:Array=_cFrame.memory;			var start:Number=Milk.READ_ONLY_START;			var end:Number=Milk.READ_ONLY_END;			for (var i:uint=start; i <= end; i++) {				to[i]=from[i];			}		}				private function copyTVars(to:Array):void {			var from:Array=_cFrame.memory;			var start:Number=Milk.T1;			var end:Number=Milk.T8;			for (var i:uint=start; i <= end; i++) {				to[i]=from[i];			}		}	}}